#### 逻辑结构的种类：

##### 划分方法一：

###### （1）线性结构：

有且仅有一个开始和一个终端节点，并且所有节点都**最多只有一个直接前趋和一个直接后趋**

例如：线性表，栈，队列，串

###### （2）非线性结构：

一个结点可能有**多个直接前趋和直接后趋**

例如：树，图



##### 划分方法二：四类基本逻辑结构

（1）集合结构：结构中的数据元素之间处理同属一个集合的关系外，无任何其他关系

（2）线性结构：结构中的数据元素之间存在着一对一的线性关系

（3）树状结构：结构中的数据元素之间存在着一对多的层次关系

（4）图状结构或网状结构：结构中的数据元素之间存在多对多的任意关系



#### 存储结构的种类：四种

##### 1，顺序存储结构：

用一组连续的存储单元**依次**存储数据元素，数据元素之间的逻辑关系由元素的存储位置来表示，c语言中用数组来实现顺序存储结构

##### 2，链式存储结构：

用一组任意的存储单元存储数据元素，数据元素之间的逻辑关系用指针来表示，c语言中用指针来实现**（存储这个元素的同时后面加上地址）**



#### 抽象数据类型（ADT）定义举例：

```c
ADT 抽象数据类型名{
   	数据对象：<数据对象的定义>
    数据关系：<数据关系的定义>
    数据操作：<基本操作的定义>
}ADT 抽象数据类型名
    
    
基本操作的定义格式为：
    基本操作名(参数表)
    	初始条件：<初始条件描述>
    	操作结果：<操作结果描述>
注意点：
    1：基本操作有两种参数：1）赋值参数：只为操作提供输入值
    				   2）引用参数：以&打头，可提供输入值和返回结果
    2：初始条件：描述了操作执行之前数据结构和参数应满足的条件，若不满足则操作失败
    3：操作结果：说明操作完成之后，数据结构的变化和返回的结果
    
```



##### Circle的定义（一个圆）

![image-20230920171419548](https://gitee.com/chen-hao111222/images/raw/master/img/202312102157005.png)



##### 构造一个复数：

```c
ADT Complex{
    //数据对象的定义
    D = {r1,r2 | r1,r2都是实数}
    //元素之间的逻辑关系的定义
    S = {<r1,r2> | r1是实部,r2是虚部}
    
    assign(&C,v1,v2)
        初始条件：空的复数已存在
        操作结果：构造复数C，r1，r2分别被赋值v1,v2
    
    //没有对应的参数，操作失败，返回相应出错的信息
   	destroy(&C)
        初始条件：复数已存在
        操作结果：复数被销毁
        
    GetReal(Z,&realPart)
        初始条件：复数已存在
        操作结果：用realPart返回反正Z的实部值
}
```



 ![image-20230920180509190](https://gitee.com/chen-hao111222/images/raw/master/img/202312102158523.png)





#### 时间复杂度

<img src="https://gitee.com/chen-hao111222/images/raw/master/img/202312102222720.png" alt="image-20230921085207795" style="zoom: 67%;" />



<img src="https://gitee.com/chen-hao111222/images/raw/master/img/202312102223722.png" alt="image-20230921085307636" style="zoom:67%;" />



![image-20230921085718274](https://gitee.com/chen-hao111222/images/raw/master/img/202312102158196.png)

从右到左，从程序的内到外



<img src="https://gitee.com/chen-hao111222/images/raw/master/img/202312102223771.png" alt="image-20230921090558946" style="zoom:67%;" />





<img src="https://gitee.com/chen-hao111222/images/raw/master/img/202312102158626.png" alt="image-20230921093935202" style="zoom:67%;" />



#### 时间复杂度的简单理解：时间增长的趋势

<img src="https://gitee.com/chen-hao111222/images/raw/master/img/202312102158443.png" alt="image-20230921110835263" style="zoom: 33%;" />

<img src="https://gitee.com/chen-hao111222/images/raw/master/img/202312102158746.png" alt="image-20230921110958499" style="zoom:33%;" />



##### 一个n嵌套一个n=n^2



<img src="https://gitee.com/chen-hao111222/images/raw/master/img/202312102158793.png" alt="image-20230921111041242" style="zoom:33%;" />

##### 一个n全套一个n^2=**n+n^2=n^2**

<img src="https://gitee.com/chen-hao111222/images/raw/master/img/202312102158435.png" alt="image-20230921111323938" style="zoom:33%;" />

##### 替换数值，不管多少行，都不会影响到算法的空间复杂度



<img src="https://gitee.com/chen-hao111222/images/raw/master/img/202312102158665.png" alt="image-20230921111546014" style="zoom:25%;" />



<img src="https://gitee.com/chen-hao111222/images/raw/master/img/202312102158057.png" alt="image-20230921111852509" style="zoom: 33%;" />



#### 空间复杂度的理解：内存空间增长的趋势

<img src="https://gitee.com/chen-hao111222/images/raw/master/img/202312102159156.png" alt="image-20230921112106290" style="zoom:33%;" />

<img src="https://gitee.com/chen-hao111222/images/raw/master/img/202312102159571.png" alt="image-20230921112132083" style="zoom:33%;" />

<img src="https://gitee.com/chen-hao111222/images/raw/master/img/202312102159705.png" alt="image-20230921112149420" style="zoom:33%;" />



##### n^2的空间复杂度就是一个一行一列的数组的复杂度

# 时间空间复杂度的重新理解

![image-20231110122858573](https://gitee.com/chen-hao111222/images/raw/master/img/202312102159132.png)

## 时间复杂度：

### O(N)

![image-20231110111923242](https://gitee.com/chen-hao111222/images/raw/master/img/202312102159034.png)

### O(N^2)

![image-20231110112312877](https://gitee.com/chen-hao111222/images/raw/master/img/202312102159114.png)

![image-20231110112521050](https://gitee.com/chen-hao111222/images/raw/master/img/202312102159099.png)

## 常用的时间复杂度量级

![image-20231110121251102](https://gitee.com/chen-hao111222/images/raw/master/img/202312102159657.png)

### O(1)

这种无论重复多少行都不会影响时间复杂度，都是

![image-20231110121402916](https://gitee.com/chen-hao111222/images/raw/master/img/202312102159835.png)

### O(logN)

![image-20231110121749209](https://gitee.com/chen-hao111222/images/raw/master/img/202312102159033.png)

### O(nlogN)

![image-20231110122016539](https://gitee.com/chen-hao111222/images/raw/master/img/202312102159771.png)

### O(nm)

![image-20231110122154360](https://gitee.com/chen-hao111222/images/raw/master/img/202312102159171.png)

## 空间复杂度：

内存增长的一个趋势，下面的x和y都是一个常数量，就是数值再大也不会影响空间的量

### O(1)

![image-20231110122535624](https://gitee.com/chen-hao111222/images/raw/master/img/202312102159675.png)

### O(n)

就是一个一维数组所需要的空间，如果是一个**二维数组**则需要**O(n^2)的空间**

![image-20231110122808438](https://gitee.com/chen-hao111222/images/raw/master/img/202312102200180.png)

# 第二章：线性表

### 2.1线性表的定义和特点

![image-20230923145251175](https://gitee.com/chen-hao111222/images/raw/master/img/202312102200290.png)

![image-20230923144953486](https://gitee.com/chen-hao111222/images/raw/master/img/202312102200585.png)

![image-20230923144849889](https://gitee.com/chen-hao111222/images/raw/master/img/202312102200771.png)



![image-20230923145446216](https://gitee.com/chen-hao111222/images/raw/master/img/202312102200102.png)



### 2.2一元多项式的运算

![image-20230923151346336](https://gitee.com/chen-hao111222/images/raw/master/img/202312102200658.png)



![image-20230923151414846](https://gitee.com/chen-hao111222/images/raw/master/img/202312102200218.png)

### 多项式的运算：（相加）

![image-20230923151703190](https://gitee.com/chen-hao111222/images/raw/master/img/202312102200410.png)



![image-20230923151736725](https://gitee.com/chen-hao111222/images/raw/master/img/202312102200442.png)



### 不用数组存储，使用链表来存储

![image-20230923151909335](https://gitee.com/chen-hao111222/images/raw/master/img/202312102200795.png)



### 总结：

![image-20230923152016326](https://gitee.com/chen-hao111222/images/raw/master/img/202312102200083.png)





### 2.3线性表的类型定义

![image-20230923152843464](https://gitee.com/chen-hao111222/images/raw/master/img/202312102200846.png)





![image-20230923153757045](https://gitee.com/chen-hao111222/images/raw/master/img/202312102200994.png)



![image-20230923153817239](https://gitee.com/chen-hao111222/images/raw/master/img/202312102200722.png)

![image-20230923153845804](https://gitee.com/chen-hao111222/images/raw/master/img/202312102201420.png)

![image-20230923153907423](https://gitee.com/chen-hao111222/images/raw/master/img/202312102201834.png)

![image-20230923153924325](https://gitee.com/chen-hao111222/images/raw/master/img/202312102201199.png)

![image-20230923153941924](https://gitee.com/chen-hao111222/images/raw/master/img/202312102201984.png)

### 2.4线性表的顺序表示和实现

![image-20230923155326483](https://gitee.com/chen-hao111222/images/raw/master/img/202312102201331.png)

#### 2.4.1线性表的顺序存储表示

![image-20230923155043108](https://gitee.com/chen-hao111222/images/raw/master/img/202312102201874.png)

###### ![image-20230923155132068](https://gitee.com/chen-hao111222/images/raw/master/img/202312102201121.png)

**线性表占用一片连续的存储空间**

![image-20230923155156710](https://gitee.com/chen-hao111222/images/raw/master/img/202312102201591.png)





![image-20230923155806946](https://gitee.com/chen-hao111222/images/raw/master/img/202312102201504.png)

#### 线性表存储空间的初始分配量

```c
#define LIST_INIT SIZE 100	//线性表存储空间的初始分配量
typedef struct{
    Elem Type elem[LIST_INIT_SIZE];
    int length;	//当前长度
}SqList;
```





#### 用c语言来写多项式的顺序存储结构类型定义

![image-20230923160415564](https://gitee.com/chen-hao111222/images/raw/master/img/202312102201492.png)



#### 图书表的顺序存储结构类型定义：

![image-20230923161021504](https://gitee.com/chen-hao111222/images/raw/master/img/202312102201671.png)

```c
#define MAXSIZE 10000
//图书表可能达到的最大长度

typedef struct //图书信息的定义
    //图书的编号
    char no[20];
    //图书名字
    char name[50];
    图书价格
    float price;
}book;

typedef struct{
    book *elem;	//存储空间的基地址
    int length;	//图书表中的当前图书个数
}SqList;	//图书表的顺序存储结构类型为SqList
```





### 补充说明：

<img src="https://gitee.com/chen-hao111222/images/raw/master/img/202312102201290.png" alt="image-20230923163848935" style="zoom: 67%;" />

ElemType:是以data[]中的元素的类型为准，比如是int则可以使用typedef int ElemType;来定义



<img src="https://gitee.com/chen-hao111222/images/raw/master/img/202312102201193.png" alt="image-20230923164648682" style="zoom:67%;" />

因为data[MaxSize]是定义一个数组存储的也是数组的第一个元素的地址，则可以直接定义一个指针*data来表示，后续在给他分配空间

<img src="https://gitee.com/chen-hao111222/images/raw/master/img/202312102201124.png" alt="image-20230923164949208" style="zoom:67%;" />

#### 内存动态分配：

```c
include <stdlib.h>
SqList L;
L.data = (ElemType*)malloc(sizeof(ElemType)*MaxSize);
```



#### c++的动态存储分配

<img src="https://gitee.com/chen-hao111222/images/raw/master/img/202312102201282.png" alt="image-20230923165140946" style="zoom:67%;" />

<img src="https://gitee.com/chen-hao111222/images/raw/master/img/202312102201746.png" alt="image-20230923165220624" style="zoom:67%;" />



### P16	第02周07--类c语言有关操作补充--------没听懂





![image-20230924093121756](https://gitee.com/chen-hao111222/images/raw/master/img/202312102201011.png)

![image-20230924093216810](https://gitee.com/chen-hao111222/images/raw/master/img/202312102202986.png)



### 2.4.2顺序表基本操作的实现

<img src="https://gitee.com/chen-hao111222/images/raw/master/img/202312102202075.png" alt="image-20230924093306979" style="zoom:50%;" />



<img src="https://gitee.com/chen-hao111222/images/raw/master/img/202312102202836.png" alt="image-20230924095232137" style="zoom: 67%;" />



#### 算法2.1：

#### 1:线性表L的初始化（参数用引用）

```c
//方法一
Status lnitList_Sq(SqList &L){	//构造一个空的顺序表L
	L.elem = new ElemType[MAXSIZE];	//为顺序表分配空间，new是c++语言
	if (!L.elem) exit(OVERFLOW);	//存储分配失败
	L.length = 0;					//空表长度为0
	return OK;
}

//方法二
Status InitList_Sq(SqList &L){
    //构造一个空的线性表L
    L.elem = (ElemType * )malloc(LIST_INIT_SIZE * sizeof(ElemType));
    if (!L.elem) exit(OVERFLOW);	//存储分配失败
    L.length = 0;					//空表长度为0
    L.listsize = LIST_INTI_SIZE;	//初始存储容量
    return OK;
}//InitList_Sq
```

####  2:销毁线性表和清空线性表

<img src="https://gitee.com/chen-hao111222/images/raw/master/img/202312102202940.png" alt="image-20230924103758901" style="zoom: 67%;" />



#### 3：线性表L的长度和判断线性表是否为空

<img src="https://gitee.com/chen-hao111222/images/raw/master/img/202312102202553.png" alt="image-20230924104113900" style="zoom: 67%;" />



#### 4：顺序表的取值

<img src="https://gitee.com/chen-hao111222/images/raw/master/img/202312102202826.png" alt="image-20230924104257340" style="zoom:67%;" />



#### 5：顺序表的查找

<img src="https://gitee.com/chen-hao111222/images/raw/master/img/202312102202218.png" alt="image-20230924104854541" style="zoom: 50%;" />

<img src="https://gitee.com/chen-hao111222/images/raw/master/img/202312102202373.png" alt="image-20230924104952982" style="zoom:50%;" />

```c
//方法一

int LocateElem(SqList L,ElemType e){
    //在线性表L中查找值为e的数据元素，返回其序号（是第几个元素）
    for(i=0;i<L.length;i++)	//i的值必须小于顺序表的元素个数
       	if(L.elem[i]==e) return i+1;	//查找成功，返回序号
  	return 0;	//查找失败，返回0
}

//方法二
int locateElem(sqList L,ElemType e){
    //在线性表L中查找值为e的数据元素，返回其序号
    i=0;
    while (i<L.length && L.elem[i] != e)i++;
    if (i<L.length) return i+1;	//查找成功，返回序号
    return 0;	//查找失败，返回0
}
```

![image-20230924110711472](https://gitee.com/chen-hao111222/images/raw/master/img/202312102202529.png)





#### 6：顺序表的插入

<img src="https://gitee.com/chen-hao111222/images/raw/master/img/202312102202033.png" alt="image-20230924111806290" style="zoom: 67%;" />

<img src="https://gitee.com/chen-hao111222/images/raw/master/img/202312102203800.png" alt="image-20230924111718592" style="zoom:67%;" />

```c
//顺序表的插入
Status Listlnsert_Sq(SqList &L,int i,ElemType e){
    if(i<1 || i>L.length+1) return ERROR;	//i值不合法
    if(L.length==MAXSIZE) return ERROR;		//当前存储空间已满
    for (j=L.length-1;j>=i-1;j--)
        L.elem[j+1] = L.elem[j];			//插入位置及之后的元素后移
    L.elem[i-1] = e;						//将新元素e放入第i个位置
    L.length++;								//增加之后，表长度增加1
    return OK;
}
```

<img src="https://gitee.com/chen-hao111222/images/raw/master/img/202312102203351.png" alt="image-20230924153936281" style="zoom:67%;" />

#### 7：顺序表的删除

<img src="https://gitee.com/chen-hao111222/images/raw/master/img/202312102203083.png" alt="image-20230924152519322" style="zoom:67%;" />

<img src="https://gitee.com/chen-hao111222/images/raw/master/img/202312102203515.png" alt="image-20230924152747991" style="zoom: 67%;" />



```c
Status ListDelete Sq(SqList &,int i){
	if ((i<1)  || (i>L.length)) return ERROR;	//检测i值的合法性
    for (j=i;j<=L.length-1;j++)					//令j=i,j的最大值是数组最后一个，自增
        L.elem[j-1] = L.elem[j];				//把删除后的数组的后一个位置的数值赋值到前一个位置
    	L.length--;
    return OK;
}
```

<img src="https://gitee.com/chen-hao111222/images/raw/master/img/202312102203898.png" alt="image-20230924153614858" style="zoom:67%;" />



### 顺序表（线性表的顺序存储结构）的特点

![image-20230924154255486](https://gitee.com/chen-hao111222/images/raw/master/img/202312102203551.png)

#### 1：查找，插入，删除三者的时间和空间复杂度

![image-20230924154346447](https://gitee.com/chen-hao111222/images/raw/master/img/202312102203427.png)

#### 2：优缺点：

![image-20230924154546541](https://gitee.com/chen-hao111222/images/raw/master/img/202312102203395.png)





### 2.5线性表的链式表示和实现

#### 特点介绍：链式存取

<img src="https://gitee.com/chen-hao111222/images/raw/master/img/202312102203344.png" alt="image-20230924154838139"  />

![image-20230924154931624](https://gitee.com/chen-hao111222/images/raw/master/img/202312102203211.png)

<img src="https://gitee.com/chen-hao111222/images/raw/master/img/202312102203276.png" alt="image-20230924155512817" style="zoom:67%;" />

<img src="https://gitee.com/chen-hao111222/images/raw/master/img/202312102203475.png" alt="image-20230924161849432" style="zoom:50%;" />

#### 结点，链表：

<img src="https://gitee.com/chen-hao111222/images/raw/master/img/202312102203269.png" alt="image-20230924155818692" style="zoom:67%;" />

#### 单链表，双链表，循环链表：

<img src="https://gitee.com/chen-hao111222/images/raw/master/img/202312102204538.png" alt="image-20230924160021847" style="zoom:67%;" />

#### 头指针，头结点，首元结点

<img src="https://gitee.com/chen-hao111222/images/raw/master/img/202312102204794.png" alt="image-20230924160708885" style="zoom: 67%;" />

<img src="https://gitee.com/chen-hao111222/images/raw/master/img/202312102204121.png" alt="image-20230924160901608" style="zoom:50%;" />



##### 讨论1：如何表示空表

无头结点时，**头指针**为空时表示空表

有头结点时，当头结点的**指针域**为空时表示空表

##### 讨论2：链表中设置头结点的好处

<img src="https://gitee.com/chen-hao111222/images/raw/master/img/202312102204212.png" alt="image-20230924161536174" style="zoom:50%;" />

##### 讨论3：额外加的头结点的数据域内装的是什么

<img src="https://gitee.com/chen-hao111222/images/raw/master/img/202312102204056.png" alt="image-20230924161708246" style="zoom:50%;" />

#### 2.5.1单链表的定义和表示

##### 1：带头结点的单链表：

数据域和指针域next（存了下一个元素的地址）

<img src="https://gitee.com/chen-hao111222/images/raw/master/img/202312102204698.png" alt="image-20230924163143419" style="zoom:50%;" />

头指针是空的则表示链表为空

##### 2：单链表的存储结构：

```c
//在c中定义一个指针*p指向a的指针
int a =5;
int *p;
p = &a;  //&为取地址运算符
```

<img src="https://gitee.com/chen-hao111222/images/raw/master/img/202312102204303.png" alt="image-20230924163538868" style="zoom: 67%;" />



```c
typedef struct Lnode{
    //声明结点的类型和指向结点的指针类型
    ElemType data;	//结点的数据域
    struct Lnode *next;		//和结构体的类型一样，包含了data和*next指针
}LNode, *LinkList;		//LinkList为指向结构体LNode结点的指针类型
```

<img src="https://gitee.com/chen-hao111222/images/raw/master/img/202312102204574.png" alt="image-20230924164044328" style="zoom: 67%;" />

定义链表用LinkList定义结点指针用LNode

##### 例题：

<img src="https://gitee.com/chen-hao111222/images/raw/master/img/202312102204156.png" alt="image-20230924164207892" style="zoom: 80%;" />

```c
//方法一：最常用的方法先定义一个结构体ElemType包含了链表中的数据域的数据再进行定义结构体
typedef Struct{
    char num[8];
    char name[8];
    int score;
}ElemType;

typedef struct Lnode{
    ElemType data;	//数据域
    struct Lnode *next;		//指针域：和结构体同样类型的指针
}Lnode, *LinkList;
```

#### 2.5.2单链表基本操作的实现

<img src="https://gitee.com/chen-hao111222/images/raw/master/img/202312102204931.png" alt="image-20230924174334486" style="zoom:67%;" />

```c

typedef Struct{
    //数据定义
}ElemType;
//类型定义
typedef struct LNode{
	Elem Type data;
    struct LNlode *next;
}LNode, *LinkList;

//定义变量：
LinkList L;		//定义链表
LNode *p;		//定义指针

//重要操作：***********************************
p=L;	//p指向链表L的头结点
s=L->next;	//s指向链表L的首元结点
p=p->next;	//p指向下一个结点
```



#### 1：初始化单链表

<img src="https://gitee.com/chen-hao111222/images/raw/master/img/202312102204774.png" alt="image-20230924170112195" style="zoom: 67%;" />

```c
Status InitList_l(LinkList &L){
    L=(LinkList)malloc(sizeof(LNode));		//用c开表示L=new LNode;
    //上一句代码的解释：sizeof来计算LNode这个结构体的大小，用malloc来给他们分配空间，经过LinkList的运算，把分配的空间变成地址
    L->next=NULL;	//把头指针置空
    return OK;
}
```

###### 补充1：判断单链表是否为空

<img src="https://gitee.com/chen-hao111222/images/raw/master/img/202312102204091.png" alt="image-20230924170631566" style="zoom:67%;" />

###### 补充2：单链表的销毁

<img src="https://gitee.com/chen-hao111222/images/raw/master/img/202312102204873.png" alt="image-20230924171555212" style="zoom:67%;" />

<img src="https://gitee.com/chen-hao111222/images/raw/master/img/202312102204283.png" alt="image-20230924171621097" style="zoom: 67%;" />

```c
Status DesrtoyList_L(LinkList %L){
    //销毁单链表L
    Lnode *p;	//LinkList p;意思是建立一个指针来指向结构体
    while(L){
        p=L;	//p指向头结点
        L=L->next;		//把结点的地址赋值给L
        free (p);
    }
    return OK;
}
```

###### 补充3：清空链表

与摧毁链表不同的是，清空链表后头结点和头指针仍然存在

![image-20230924173340094](https://gitee.com/chen-hao111222/images/raw/master/img/202312102205302.png)

![image-20230924173405546](https://gitee.com/chen-hao111222/images/raw/master/img/202312102205162.png)

```c
//清空链表：
Status ClearList(LinkList &L){
	Lnode *p,*q;	//定义两个指针
	p=L->next;	//把L的指针域赋值给P
    while(p){
        q = p->next;	//q指向p的下一个元素
        delete p;	//清空
        p=q;	//循环
    }
    L->next = NULL;		//头结点指针置空
    return OK;
}
```

###### 注意：操作开始想从头结点开始还是首元结点开始

```c
//从头结点开始操作
p = L;
//从首元结点开始操作
p = L->next;	//p指向头结点的指针域就是首元结点的地址
```

#### 2：单链表的基本操作

![image-20230924174504707](https://gitee.com/chen-hao111222/images/raw/master/img/202312102205260.png)



##### 求单链表的表长

![image-20230924173805009](https://gitee.com/chen-hao111222/images/raw/master/img/202312102205050.png)

```c
int ListLength_L(LinkList L){	//返回L中的数据元素个数
    LinkList p;  //LNode *p;
    p = L->next;	//p指向首元结点
    i = 0;
    while(p){		//如果p为真则继续计数
        i++;
        p=p->next;	//p指向下一个结点
    }
    return i;	//返回元素个数
}
```



##### 基本操作1：取值

<img src="https://gitee.com/chen-hao111222/images/raw/master/img/202312102205168.png" alt="image-20230924175123367" style="zoom:67%;" />

<img src="https://gitee.com/chen-hao111222/images/raw/master/img/202312102205532.png" alt="image-20230924175402179" style="zoom:67%;" />





```c
Status GetElem_L(LinkList L, int i, ElemType &e){
    //获取线性表L中的某个数据元素的内容，通过变量e返回
    p=L->next; j=1;		//p指向首元结点，把j置一
    while(p&&j<i){		//p不为空和j<i才执行
        //向后扫描，直到p指向第i个元素或p为空
        p=p->next; ++j;		//p指向下一个结点循环，自增j
    }
    if(!p || j>i) return ERROR;		//如果p为空或第i个元素不存在 报错
    e=p->data;		//取第i的值出来赋值给e保存
    return OK;
}//GetElem_L
```



##### 基本操作2：按值查找

<img src="https://gitee.com/chen-hao111222/images/raw/master/img/202312102205836.png" alt="image-20230924180633961" style="zoom:67%;" />

<img src="https://gitee.com/chen-hao111222/images/raw/master/img/202312102205319.png" alt="image-20230924180653770" style="zoom:67%;" />

<img src="https://gitee.com/chen-hao111222/images/raw/master/img/202312102205626.png" alt="image-20230924185701369" style="zoom: 67%;" />

```c
//在线性表L中查找值为e的数据元素的位置序号
int LocateElem_L(LinkList, Elemtype e){
    //返回L中值为e的数据元素的位置序号，查找失败返回0
    p=L->next;j=1;	//从首元结点开始
    while (p && p->data!=e)		//p为真，没找到对应的值时继续执行
    {p=p->next;j++;}		//p指向下一个结点
    if(p) return j;		//如果p为真，返回j，p经过循环之后得到的数值是对应查找值的地址，找到后返回序号
    else return 0;
}
```

##### 基本操作3：插入

思路：在i处插入元素，先找到i-1的位置，生成一个新结点，先把i处的地址赋值给新结点的next，再把新结点的地址赋值给i-1的next处

**a(i-1)在a(i)的前面**  所以新结点的指针域保留a(i)的地址，而新结点的地址保存在上一个结点a(i-1)处

<img src="https://gitee.com/chen-hao111222/images/raw/master/img/202312102205934.png" alt="image-20230924192123187" style="zoom:67%;" />

<img src="https://gitee.com/chen-hao111222/images/raw/master/img/202312102205459.png" alt="image-20230924192156136" style="zoom: 67%;" />



```c
Status ListInsert_L(LinkList &L,int i,ElemType e){
    p=L;j=0;	//从头结点开始
    while(p && j<i-1){p=p->next;++j}	//寻找第i-1个结点，使得p指向下一个结点继续
    if(!p || j>i-1) return ERROR;	//i大于表长+1或者小于1，插入位置非法
    s=new LNode; s->data=e;		//生成新结点s，将结点s的数据域置为需要插入的元素e
    //s = (LinkList*)malloc(sizeof(Lnode));
    s->next=p->next;	//把原来存放在i-1结点指针域的第i结点的地址赋值给新结点的指针域使其为第i个结点的地址
    p->next=s;		//p是找到的第i-1的结点，那么就把新结点的地址赋值给i-1结点的指针域
    return OK;
}
```



##### 基本操作4：删除

<img src="https://gitee.com/chen-hao111222/images/raw/master/img/202312102205725.png" alt="image-20230924201411719" style="zoom:67%;" />

步骤描述：先找到第i个结点，保存其值后，把它存储在第i结点指针域的地址删除并指向第i+1结点的地址，

<img src="https://gitee.com/chen-hao111222/images/raw/master/img/202312102205191.png" alt="image-20230924201324446" style="zoom:67%;" />



```c
Status ListDelete_L(LinkList &L,int i,ElemType &e){
    p=L;j=0;	//从头结点开始
    while(p->next && j<i-1){p=p->next;++j;}		//寻找第i个结点，并使得p指向前驱
    //p->next:如果next==NULL则表示没搜索到
    if(!(p->next) || j>i-1) return ERROR;	//删除位置不合理
    q=p->next;	//q就是找到的第i-1个结点的下一个值i结点，就是题目需要删除的结点
    p->next=q->next;	//把i-1的结点的指针域改为i+1结点的地址（q->next 就是i+1结点的地址之前保存在第i个结点指针域）
    delete q;		//释放删除结点的空间
    return OK;
}
```



单链表的查找，插入，删除算法时间效率分析

<img src="https://gitee.com/chen-hao111222/images/raw/master/img/202312102205456.png" alt="image-20230924202706025" style="zoom:67%;" />

#### 建立链表的两种方法

#### 头插法

先进去的在尾，后进去的在头

(头----->尾)

L,a,b,c中要把d插入到L和a之间

<img src="https://gitee.com/chen-hao111222/images/raw/master/img/202312102205932.png" alt="image-20230924204424183" style="zoom:67%;" />

<img src="https://gitee.com/chen-hao111222/images/raw/master/img/202312102206465.png" alt="image-20230924204618626" style="zoom:67%;" />

<img src="https://gitee.com/chen-hao111222/images/raw/master/img/202312102206838.png" alt="image-20230924204633609" style="zoom:67%;" />

```c
void CreateList_H(LinkList &L,int n){
    L=new LNode;	//先建立一个带头结点的单链表
    L->next=NULL;	//把头结点的指针域置空
    for(i=n;i>0;--i){
        p=(LNode*)malloc(sizeof(LNode));	//生成新结点
        scanf(&p->data);	//输入新结点的数据域
        p->next=L->next;	//把头结点指针域中原本下一个结点的地址赋值给新结点的指针域指向上一个结点
        L->next=p;			//把新结点的地址赋值给头结点的指针域
    }
}
```

#### 尾插法

从尾部插入新结点，先进为头，后进为尾

(头<---尾)

r是固定的尾结点的指针，建立首元结点p，输入data值，先把p的指针域置空，再把p的地址赋值给上一个结点，然后接过固定尾结点r指针成为尾结点

<img src="https://gitee.com/chen-hao111222/images/raw/master/img/202312102206387.png" alt="image-20230924205930564" style="zoom:67%;" />

<img src="https://gitee.com/chen-hao111222/images/raw/master/img/202312102206143.png" alt="image-20230924210305974" style="zoom:67%;" />

```c
//正位序输入n个元素的值，建立代表头结点的单链表L
void CreateList_R(LinkList &L,int n){
    L = new LNode;	//建立空表
	L->next = NULL;	//把头结点置空
    r=L;		//尾指针r指向头结点
    for(i=0;i<n;++i){
        p = new LNode;
        scanf(&p->data); //输入新结点的数据域的值
        p->next = NULL;	//把新结点的指针域置空
        r->next=p;	//把新结点的地址赋值给上一个结点的指针域
        r=p;	/r指向新的结点
    }
}//CreateList_R
```





#### 2.5.3循环链表

表中**最后的一个结点的指针域指向头结点**，整个链表形成一个环

优点：从表中任意结点出发可以找到表中其他结点

![image-20230928095423331](https://gitee.com/chen-hao111222/images/raw/master/img/202312102206859.png)

##### 循环链表的终止条件：

在循环链表中**没有空指针**，所以和单链表表示空表的条件不一样，终止条件不同

判断循环链表为空的条件是：判断尾指针与头指针是否相等

![image-20230928095625144](https://gitee.com/chen-hao111222/images/raw/master/img/202312102206463.png)

![image-20230928095801649](https://gitee.com/chen-hao111222/images/raw/master/img/202312102206480.png)





###### 带尾指针的循环链表的合并（将Tb合并带Ta之后）

![image-20230929115751019](https://gitee.com/chen-hao111222/images/raw/master/img/202312102206817.png)



![image-20230929115853384](https://gitee.com/chen-hao111222/images/raw/master/img/202312102206786.png)



#### 2.5.4双向链表

**双向链表：就是又有尾指针next，又有头指针prior**

最后一个结点next没有后继指针，头结点的prior为空**（头头空，尾尾空）**

**判断是否空表：头结点的prior和next指针都为空**

<img src="https://gitee.com/chen-hao111222/images/raw/master/img/202312102206322.png" alt="image-20230929123122739" style="zoom:80%;" />



##### 双向循环链表：

**头结点的prior指针指向尾结点，尾结点的next指针指向头结点**

头结点的前指针指向尾结点，尾结点的尾指针指向头结点

<img src="https://gitee.com/chen-hao111222/images/raw/master/img/202312102206255.png" alt="image-20230929123707740" style="zoom:80%;" />

##### 双向链表结构的对称性：

<img src="https://gitee.com/chen-hao111222/images/raw/master/img/202312102206953.png" alt="image-20230929123749618" style="zoom:80%;" />

##### 双向链表的插入：

<img src="https://gitee.com/chen-hao111222/images/raw/master/img/202312102206395.png" alt="image-20230929125212611" style="zoom:80%;" />



<img src="https://gitee.com/chen-hao111222/images/raw/master/img/202312102206995.png" alt="image-20230929125343020" style="zoom:80%;" />

```c
if(!(p=GetElemP_DuL(L,i))) return ERROR;
//在链表L中找到第i个结点，把他赋值给p，让p指向第i个结点
```



##### 双向链表的删除：

<img src="https://gitee.com/chen-hao111222/images/raw/master/img/202312102207594.png" alt="image-20230929125825840" style="zoom: 80%;" />

1：修改前驱结点的next域，把删除结点的next赋值给他

2：修改后继结点的prior域，把删除结点的prior域赋值给他

<img src="https://gitee.com/chen-hao111222/images/raw/master/img/202312102207514.png" alt="image-20230929130224790" style="zoom:80%;" />



#### 单链表，循环链表和双向链表的时间效率比较

![image-20230929130611964](https://gitee.com/chen-hao111222/images/raw/master/img/202312102207850.png)



#### 2.6顺序表和链表的比较

![image-20230929131318410](https://gitee.com/chen-hao111222/images/raw/master/img/202312102207267.png)

![image-20230929131255519](https://gitee.com/chen-hao111222/images/raw/master/img/202312102207308.png)

![image-20230929131351810](https://gitee.com/chen-hao111222/images/raw/master/img/202312102207777.png)



#### 2.7线性表的应用：

线性表的合并：两个集合求并集

有序表的合并：会有重复的数值

![image-20230929131708274](https://gitee.com/chen-hao111222/images/raw/master/img/202312102207012.png)

##### 线性表的合并：

![image-20230929131925360](https://gitee.com/chen-hao111222/images/raw/master/img/202312102207393.png)



```c
//线性表的合并
void union(List &La,List Lb){//合并两个集合，用La来返回，找元素个数较小的值，再在另外一个元素中对比是否存在
    //先求两个链表的长度
    La_len = ListLength(La);
    Lb_len = ListLength(Lb);
    //要在链表b中依次看链表a有没有
    for(i=1;i<=Lb_len;i++){
        GetElem(Lb,i,e); 	//每个元素都取出来看看他的值
        //拿出来比较，如果相等，则再查找下一个值，如果不相等就拿出来插入到a链表中
        if(!LocateElem(La,e))	Listlnsert(&La,++La_len,e);
    }

}	
```



##### 有序表的合并：

![image-20230929132939577](https://gitee.com/chen-hao111222/images/raw/master/img/202312102207731.png)

![image-20230929133233313](https://gitee.com/chen-hao111222/images/raw/master/img/202312102207952.png)

![image-20230929133440399](https://gitee.com/chen-hao111222/images/raw/master/img/202312102207826.png)

```c
void MergeList_Sq(SqList LA, SqList LB, SqList &LC){
    pa=LA.elem;		//pa指向LA第一个元素
    pb=LB.elem;		//pb指向LB第一个元素
    LC.length=LA.length+LBlength;	//数组c的长度等于bc相加
    LC.elem=new ElemType[LC.length];	//为合并后的新表分配数组空间
    pc=LC.elem;		//pc指向LC第一个元素
    //分别指向最后一个元素
    pa_last=LA.elem+LA.length-1;
    pb_last=LB.elem+LB.length-1;
    while(pa<=pa_last && pb<=pb_last)(
    	if(*pa<*pb) *pc++=*pa++;  //对比取出来的a和b的数组哪个小就取哪个
        else *pc++=*pb++;
    )
        //如果一个数组已经到了表尾，将另外一个表的所有元素加到数组c中
        while(pa<=pa_last) *pc++=*pa++;
    	while(pb<=pb_last) *pc++=*pb++;
}//MergeList_Sq
```



#### 2.7.2有序表的合并-链表实现

![image-20230929134048449](https://gitee.com/chen-hao111222/images/raw/master/img/202312102207297.png)

![image-20230929134117938](https://gitee.com/chen-hao111222/images/raw/master/img/202312102207032.png)

![image-20230929134141404](https://gitee.com/chen-hao111222/images/raw/master/img/202312102207642.png)

![image-20230929134222634](https://gitee.com/chen-hao111222/images/raw/master/img/202312102208914.png)

```c
void MergeList_L(LinkList &La,LinkList &Lb,LinkList &Lc){
    //从链表的首元结点开始操作
    pa=La->next;
    pb=Lb->next;
    pc=Lc=La;	//用La的头结点作为Lc的头结点
    while(pa && pb){
        if (pa->data<=pb->data){
            pc->next=pa;	//比较之后，pa的值较小则把pa的地址赋值给c的next指针
            pa=pa->next;	//继续往下一个结点走
        };
        else {
            pc->next=pb;	//同上
            pc=pb;
            pb=pb->next;
        }
    }
    //判断pa链表是否还有结点，如有则把地址赋值给pc指针域，没有赋值pc的地址
    //pc->next=pa?pa:pb;
    if(pa) pc->next=pa;
    else pc->next=pb;
}
```

#### （链表未重复看的东西）

#### 2.8案例分析与实现

##### 实现两个多项式的相加运算：

![image-20230929135035196](https://gitee.com/chen-hao111222/images/raw/master/img/202312102208883.png)



##### 稀疏多项式的运算：

![image-20230929135228947](https://gitee.com/chen-hao111222/images/raw/master/img/202312102208200.png)

![image-20230929135349941](https://gitee.com/chen-hao111222/images/raw/master/img/202312102208944.png)

![image-20230929135451417](https://gitee.com/chen-hao111222/images/raw/master/img/202312102208602.png)

##### 多项式相加：多项式创建

![image-20230929135553520](https://gitee.com/chen-hao111222/images/raw/master/img/202312102208186.png)

![image-20230929135607828](https://gitee.com/chen-hao111222/images/raw/master/img/202312102208746.png)

![image-20230929135857441](https://gitee.com/chen-hao111222/images/raw/master/img/202312102208081.png)

##### 图书信息管理系统：

![image-20230929140236757](https://gitee.com/chen-hao111222/images/raw/master/img/202312102208963.png)

![image-20230929140314502](https://gitee.com/chen-hao111222/images/raw/master/img/202312102208242.png)



# 第三章：栈和队列

### 3.1栈和队列的定义和特点

![image-20231012093737775](https://gitee.com/chen-hao111222/images/raw/master/img/202312102208770.png)

#### 栈的应用：

**后进先出，插入和删除都要在表尾进行**，手电筒插入电池

![image-20231012093908034](https://gitee.com/chen-hao111222/images/raw/master/img/202312102208339.png)

#### 队列的应用：

**先进先出，插入在表尾，删除在表头**，排队上地铁

![image-20231012094204972](https://gitee.com/chen-hao111222/images/raw/master/img/202312102208050.png)



#### 3.3.1栈的定义和特点：

![image-20231012095048560](https://gitee.com/chen-hao111222/images/raw/master/img/202312102208441.png)

![image-20231012095207077](https://gitee.com/chen-hao111222/images/raw/master/img/202312102208922.png)

![image-20231012095245789](https://gitee.com/chen-hao111222/images/raw/master/img/202312102208733.png)

##### 入栈：

![image-20231012095324109](https://gitee.com/chen-hao111222/images/raw/master/img/202312102208874.png)

##### 出栈：

后面进来的元素最先出去

![image-20231012095408320](https://gitee.com/chen-hao111222/images/raw/master/img/202312102208018.png)

##### 思考：

可以自己想一下下面的这几种是出栈顺序是怎么来的

![image-20231012095529405](https://gitee.com/chen-hao111222/images/raw/master/img/202312102209186.png)

##### 栈的相关概念：

![image-20231012095750016](https://gitee.com/chen-hao111222/images/raw/master/img/202312102209815.png)

##### 栈与一般线性表的区别：

逻辑关系都是一对一，**区别在于运算规则**

![image-20231012095827084](https://gitee.com/chen-hao111222/images/raw/master/img/202312102209729.png)



#### 3.1.2 队列的定义和特点：

先进去的元素最先出去，只能在最后插入元素，不能插队

![image-20231012100107974](https://gitee.com/chen-hao111222/images/raw/master/img/202312102209726.png)

##### 队列相关概念：

![image-20231012100253569](https://gitee.com/chen-hao111222/images/raw/master/img/202312102209202.png)





### 3.2案例介绍

![image-20231016160853488](https://gitee.com/chen-hao111222/images/raw/master/img/202312102209194.png)

##### 例1：进制转换

![image-20231016161139799](https://gitee.com/chen-hao111222/images/raw/master/img/202312102209707.png)

##### 例2：括号匹配的检测

![image-20231016161329430](https://gitee.com/chen-hao111222/images/raw/master/img/202312102209205.png)

**方法：**

![image-20231016161400272](https://gitee.com/chen-hao111222/images/raw/master/img/202312102209794.png)



##### 例3：表达式求值

![image-20231016161546805](https://gitee.com/chen-hao111222/images/raw/master/img/202312102209865.png)

![image-20231016161610562](https://gitee.com/chen-hao111222/images/raw/master/img/202312102209953.png)



##### 例4：舞伴问题

![image-20231016162555424](https://gitee.com/chen-hao111222/images/raw/master/img/202312102209370.png)

### 3.3栈的表示和操作

![image-20231016162740173](https://gitee.com/chen-hao111222/images/raw/master/img/202312102209171.png)

##### 3.3.1各种操作：

![image-20231016163028094](https://gitee.com/chen-hao111222/images/raw/master/img/202312102209875.png)



### 顺序存储：

![image-20231016163441667](https://gitee.com/chen-hao111222/images/raw/master/img/202312102210089.png)

顶指针和底指针都指向序号0时则表示空栈

每当加入和删除一个元素时，top指针都要向上或向下移动。

![image-20231016163802273](https://gitee.com/chen-hao111222/images/raw/master/img/202312102210348.png)

##### 溢出的情况：

![image-20231016163957078](https://gitee.com/chen-hao111222/images/raw/master/img/202312102210121.png)

### 3.3.2栈的顺序和链式存储：

![image-20231016163138830](https://gitee.com/chen-hao111222/images/raw/master/img/202312102210237.png)

![image-20231016164809599](https://gitee.com/chen-hao111222/images/raw/master/img/202312102210922.png)

##### 顺序栈的定义：

![image-20231016165018598](https://gitee.com/chen-hao111222/images/raw/master/img/202312102210188.png)

```c
#define MAXSIZE 100
typedef struct{
    SElemType *base;	//栈底指针
    SElemType *top;		//栈顶指针
    int stacksize;		//栈可用最大容量
}SqStack;
```



##### 顺序表的初始化：

![image-20231016165452546](https://gitee.com/chen-hao111222/images/raw/master/img/202312102210460.png)

```c
Status InitStack(SqStack &S){	//构造一个空栈
    S.base = (SElemType*)malloc(MAXSIZE*sizeof(SElemType));		//给栈分配一个空间
    if (!S.base) exit (OVERFLOW);	//存储分配失败
    S.top = S.base;		//栈顶指针等于栈底指针
    S.stacksize = MAXSIZE;		//把空间的值赋值为栈的最大存储值
    return OK;
}
```



##### 判断是否为空：

只要底和顶指针都指向序号0则表示为空栈

![image-20231016170433682](https://gitee.com/chen-hao111222/images/raw/master/img/202312102210651.png)



##### 求顺序栈的长度：

用顶指针减去底指针

![image-20231016170707277](https://gitee.com/chen-hao111222/images/raw/master/img/202312102210162.png)



##### 清空顺序栈：

先判断栈是否为真，然后再让顶指针指向底指针

![image-20231016170942927](https://gitee.com/chen-hao111222/images/raw/master/img/202312102210385.png)



##### 销毁顺序栈：

如果栈不为空则删除底指针，使得S.stacksize置零，顶和底指针都置空

![image-20231016171124246](https://gitee.com/chen-hao111222/images/raw/master/img/202312102210442.png)



##### 顺序栈的入栈：

*S.top：表示取到指针指向的那个空间进行运算

![image-20231016171633032](https://gitee.com/chen-hao111222/images/raw/master/img/202312102211146.png)

##### 顺序栈的出栈：

一开始top指针指向栈顶的下一个空间，需要先让top指针指向栈顶元素，再把他赋值给e出栈

![image-20231016172353430](https://gitee.com/chen-hao111222/images/raw/master/img/202312102211126.png)



### 链式存储：

- 没有头指针
- 头指针指向栈顶
- 指针方向：栈顶到栈底，An-A1
- 空栈：头指针指向为空
- 和链表一样：都有数据域和指针域
- 链栈不存在栈满的情况

![image-20231016195710750](https://gitee.com/chen-hao111222/images/raw/master/img/202312102211983.png)





### 3.3.3链栈的表示和实现：

##### 链栈的初始化：

**头指针为空**

![image-20231016200154543](https://gitee.com/chen-hao111222/images/raw/master/img/202312102211834.png)

##### 判断链栈是否为空：

**还是看头指针是否为空**

![image-20231016200301735](https://gitee.com/chen-hao111222/images/raw/master/img/202312102211183.png)

##### 链栈的入栈：

步骤1：新建一个结点p，有数据域和指针域

步骤2：把新元素e赋值给p结点的数据域

步骤3：把新结点的指针域指向栈顶结点地址

步骤4：把栈顶指针S指向新结点p

![image-20231016200851753](https://gitee.com/chen-hao111222/images/raw/master/img/202312102211675.png)



##### 链栈的出栈：

步骤1：把要出栈的数据域赋值给e

步骤2：把栈顶指针S赋值给新指针P

步骤3：把栈顶指针指向下一个结点

![image-20231016201226464](https://gitee.com/chen-hao111222/images/raw/master/img/202312102211594.png)



##### 取栈顶元素：

因为后进先出，所以只需要直接取的栈顶元素的值就好了

![image-20231016201451694](https://gitee.com/chen-hao111222/images/raw/master/img/202312102211776.png)



### 递归的定义：

![image-20231016201839952](https://gitee.com/chen-hao111222/images/raw/master/img/202312102211822.png)



![image-20231016202148536](https://gitee.com/chen-hao111222/images/raw/master/img/202312102211914.png)

![image-20231016202220888](https://gitee.com/chen-hao111222/images/raw/master/img/202312102211139.png)

![image-20231016202236165](https://gitee.com/chen-hao111222/images/raw/master/img/202312102211536.png)



![image-20231016202253928](https://gitee.com/chen-hao111222/images/raw/master/img/202312102211796.png)



##### 递归的分治法：

![image-20231016202422759](https://gitee.com/chen-hao111222/images/raw/master/img/202312102211617.png)

![image-20231016202546106](https://gitee.com/chen-hao111222/images/raw/master/img/202312102211041.png)



##### 函数调用前后：

![image-20231016202909799](https://gitee.com/chen-hao111222/images/raw/master/img/202312102211853.png)

### 嵌套调用：

最后被调用的函数最先返回，并且从后往前逐个返回

![image-20231016203246797](https://gitee.com/chen-hao111222/images/raw/master/img/202312102211931.png)

##### 例子：

![image-20231016203555252](https://gitee.com/chen-hao111222/images/raw/master/img/202312102212839.png)

![image-20231016203642046](https://gitee.com/chen-hao111222/images/raw/master/img/202312102212858.png)

![image-20231016203826193](https://gitee.com/chen-hao111222/images/raw/master/img/202312102212152.png)

### 递归优缺点：

![image-20231016203948861](https://gitee.com/chen-hao111222/images/raw/master/img/202312102212810.png)

### 递归—>非递归：

![image-20231016204338622](https://gitee.com/chen-hao111222/images/raw/master/img/202312102212189.png)

##### 尾递归：

![image-20231016204030595](https://gitee.com/chen-hao111222/images/raw/master/img/202312102212471.png)

##### 单向递归：

![image-20231016204050686](https://gitee.com/chen-hao111222/images/raw/master/img/202312102212003.png)

##### 循环递归：

![image-20231016204144749](https://gitee.com/chen-hao111222/images/raw/master/img/202312102212055.png)

### 3.5队列：

**队头出队，队尾入队**，先入先出

![image-20231016204527300](https://gitee.com/chen-hao111222/images/raw/master/img/202312102212421.png)

#### 队列相关概念：

![image-20231016204657832](https://gitee.com/chen-hao111222/images/raw/master/img/202312102212634.png)

![image-20231016204752749](https://gitee.com/chen-hao111222/images/raw/master/img/202312102212506.png)

#### 常见应用：

有多个需要使用有限资源的用户，需要排队进行使用

![image-20231016204824487](https://gitee.com/chen-hao111222/images/raw/master/img/202312102212785.png)



#### 3.5.1数据类型定义：

![image-20231016204955925](https://gitee.com/chen-hao111222/images/raw/master/img/202312102212388.png)



#### 3.5.2队列的顺序实现：

头尾指针是两个整数int

![image-20231016205438437](https://gitee.com/chen-hao111222/images/raw/master/img/202312102212165.png)





#### 初始化，入队，出队

入队：队尾进去则rear自增

出队：队头出队，把出队的值输入到x中

空队：队头队尾相等

![image-20231016210124376](https://gitee.com/chen-hao111222/images/raw/master/img/202312102212235.png)

![image-20231016211108616](https://gitee.com/chen-hao111222/images/raw/master/img/202312102213180.png)

#### 解决假上溢的方法：

当尾指针rear为最大值时，如果向量开始端空着的话，直接指向开始端

![image-20231016211328499](https://gitee.com/chen-hao111222/images/raw/master/img/202312102213738.png)

用取余的方式，只有当指针等于最大值时mod最大值=0，相当于重新开始

![image-20231016211817148](https://gitee.com/chen-hao111222/images/raw/master/img/202312102213987.png)



#### 循环队列的初始化：

创建数组分配空间，Q.front和Q.rear都是地址，所以是一个指针

![image-20231017163536512](https://gitee.com/chen-hao111222/images/raw/master/img/202312102213415.png)



#### 循环队列的长度：

由于是循环队列，尾指针可能指向0，所以需要用（尾指针-头指针+容量）再取余容量

![image-20231017164007169](https://gitee.com/chen-hao111222/images/raw/master/img/202312102213053.png)

#### 循环队列入队：

先判断是否上溢出，再把新元素插入到队尾指针处，再处理队尾指针的指向哪里

![image-20231017164331196](https://gitee.com/chen-hao111222/images/raw/master/img/202312102213352.png)



#### 循环队列的出队：

和入队操作相似

![image-20231017164635862](https://gitee.com/chen-hao111222/images/raw/master/img/202312102213553.png)

取队头元素：

和出队的差别是：不需要改变队头指针，因为并没有改变队头元素的值，只是获得一个值而已

![image-20231017164757747](https://gitee.com/chen-hao111222/images/raw/master/img/202312102213194.png)



### 3.5.3链队-队列的链式表示

![image-20231017165333381](https://gitee.com/chen-hao111222/images/raw/master/img/202312102213755.png)



#### 队列的链式定义：

```c
//定义出链队的类型
#define MAXQSIZE 100
typedef struct Qnode{
    QElemType data;
    stuct Qnode *next;
}QNode, *QuenePtr;

//定义链队的头尾指针
typedef struct{
    QuenePtr front;		//队头指针
    QuenePtr rear;		//队尾指针
}LinkQueue;
//如果需要使用头尾指针
Q.front或Q.rear
```



#### 链队的出入队的指针变化情况：

出队：从队头去除，头指针需要不断指向后面一个元素

入队：从队尾添加，尾指针需要不断指向后面一个元素

![image-20231017165910444](https://gitee.com/chen-hao111222/images/raw/master/img/202312102213824.png)



#### 链队的初始化：

先创建一个空间，头尾指针同时指向第一个结点，头结点的指针域置空

![image-20231017170250254](https://gitee.com/chen-hao111222/images/raw/master/img/202312102213249.png)



#### 销毁链队：

- 先创建一个指针p指向头结点
- 开始后把p指向头结点的下一个结点
- 释放头结点，移动头指针指向下一个结点
- 再把头指针指向p指针

![image-20231017170550401](https://gitee.com/chen-hao111222/images/raw/master/img/202312102213353.png)



#### 链队的入队：

创建一个新结点，数据域赋值，指针域置空，尾指针指向的结点的指针域指向新结点，使尾指针指向新结点

![image-20231017171005572](https://gitee.com/chen-hao111222/images/raw/master/img/202312102213932.png)



#### 链队的出队：

![image-20231017171607590](https://gitee.com/chen-hao111222/images/raw/master/img/202312102213370.png)

![image-20231017171625351](https://gitee.com/chen-hao111222/images/raw/master/img/202312102214042.png)

注意：如果需要删除的结点是尾指针指向的结点，则不仅仅需要改变指针域的值，也需要改变尾指针指向哪里

![image-20231017171438756](https://gitee.com/chen-hao111222/images/raw/master/img/202312102214636.png)



#### 取队头元素：

队头元素的结点就在头指针的下一个结点里面，取出来就可以了

![image-20231017171753643](https://gitee.com/chen-hao111222/images/raw/master/img/202312102214106.png)



# 第四章：串的定义

串：零个或多个任意字符组成的有限序列

![image-20231017181551695](https://gitee.com/chen-hao111222/images/raw/master/img/202312102214697.png)

#### 子串和真子串：

![image-20231017181718482](https://gitee.com/chen-hao111222/images/raw/master/img/202312102214627.png)

#### 术语介绍：

#### 子串，主串，字符位置

#### 子串位置，空格串

- 子串位置：**子串第一个字符**在主串中的位置

![image-20231017182009366](https://gitee.com/chen-hao111222/images/raw/master/img/202312102214882.png)

子串，主串，字符位置，子串位置，空格串

##### 串相等：

**所有空串都是相等的**

![image-20231017182205502](https://gitee.com/chen-hao111222/images/raw/master/img/202312102214595.png)



#### 串的类型定义：

![image-20231017212248467](https://gitee.com/chen-hao111222/images/raw/master/img/202312102214330.png)

![image-20231017212332506](https://gitee.com/chen-hao111222/images/raw/master/img/202312102214514.png)

#### 串的存储结构：

**顺序串，链串**

![image-20231017213240488](https://gitee.com/chen-hao111222/images/raw/master/img/202312102214811.png)





##### 串的顺序存储结构：

- 在初始化着字符串的时候需要多加一，一共256个字符，相当于是从0-255
- 和其他有区别：**初始化**的时候定义的是一个字符串char而不是int型

![image-20231017213525385](https://gitee.com/chen-hao111222/images/raw/master/img/202312102214228.png)



##### 串的链式存储结构：

当一个数据域只能存储一个字符的时候，指针域有四个字节导致需要存储的密度较低

让一个数据域增加存储多个字符就可以提高存储密度

![image-20231017214505220](https://gitee.com/chen-hao111222/images/raw/master/img/202312102215715.png)

##### 块链结构：

![image-20231017214820739](https://gitee.com/chen-hao111222/images/raw/master/img/202312102215370.png)



#### 串的模式匹配算法：

![image-20231017215145713](https://gitee.com/chen-hao111222/images/raw/master/img/202312102215082.png)



##### BF算法：

**寻找子串的位置再主串中的位置：**

（i-j+1）：当i-j之后下题中会发现多退了一个，所以加一

（i-j+1）+1：再加一的原因是找到原来位置的下一个位置，退到第二个字符的位置

![image-20231017220031309](https://gitee.com/chen-hao111222/images/raw/master/img/202312102215133.png)

当再进行后发现还是没有匹配后再执行上面回溯步骤

![image-20231017220535229](https://gitee.com/chen-hao111222/images/raw/master/img/202312102215785.png)

当后面没有字符之后则停止

![image-20231017220611748](https://gitee.com/chen-hao111222/images/raw/master/img/202312102215296.png)



![image-20231017220747435](https://gitee.com/chen-hao111222/images/raw/master/img/202312102215907.png)



##### BF算法设计思想：

![image-20231018075432111](https://gitee.com/chen-hao111222/images/raw/master/img/202312102215970.png)



###### 算法描述：

**难点：**

- 循环结束条件：当比较完主串都找不到，当子串中所有字符都和主串中的相同后
- 当主串和子串中字符不一致时，主串的序号怎么取
- 当匹配成功后，怎么返回子串第一个字符在主串中的位置

![image-20231018075924132](https://gitee.com/chen-hao111222/images/raw/master/img/202312102215962.png)



**改变从主串中查找的首位置：**

![image-20231018080514193](https://gitee.com/chen-hao111222/images/raw/master/img/202312102215432.png)

##### BF算法的时间复杂度：

![image-20231018080815911](https://gitee.com/chen-hao111222/images/raw/master/img/202312102215128.png)



##### KMP算法：

![image-20231018083956657](https://gitee.com/chen-hao111222/images/raw/master/img/202312102215075.png)

![image-20231018084027093](https://gitee.com/chen-hao111222/images/raw/master/img/202312102215211.png)

和BF算法不同的是j不再是一个序号，而是一个指针，KMP的重点就是怎么算next[j]的值

![image-20231018084117527](https://gitee.com/chen-hao111222/images/raw/master/img/202312102215834.png)

![image-20231018084244246](https://gitee.com/chen-hao111222/images/raw/master/img/202312102215754.png)

- 当j=1开始时，next[j]=0
- 从头开始的k-1和从k-1开始的有五个字符是一样的所以：k-1=5,k=6
- 前面找不到相同的k-1的值为其他情况：next[j]=1

![image-20231018083835718](https://gitee.com/chen-hao111222/images/raw/master/img/202312102216466.png)

###### 算法描述：

![image-20231018085124565](https://gitee.com/chen-hao111222/images/raw/master/img/202312102216066.png)

**定义next函数怎么求：**

![image-20231018085255703](https://gitee.com/chen-hao111222/images/raw/master/img/202312102216864.png)

###### 改进next函数：

![image-20231018085031169](https://gitee.com/chen-hao111222/images/raw/master/img/202312102216141.png)

![image-20231018085340648](https://gitee.com/chen-hao111222/images/raw/master/img/202312102216858.png)

理解怎么算的就可以了，程序无需记忆

![image-20231018085421793](https://gitee.com/chen-hao111222/images/raw/master/img/202312102216692.png)





## 4.4数组

#### 一维数组：

![image-20231018091213137](https://gitee.com/chen-hao111222/images/raw/master/img/202312102216095.png)

#### 二维数组：

![image-20231018091432401](https://gitee.com/chen-hao111222/images/raw/master/img/202312102216397.png)

![image-20231018091824462](https://gitee.com/chen-hao111222/images/raw/master/img/202312102216354.png)



#### 三维数组：

![image-20231018092006696](https://gitee.com/chen-hao111222/images/raw/master/img/202312102216417.png)

**数组不做插入和删除的操作，因为这样会改变他的结构，只是取元素和修改元素**



### 4.4.1数据类型定义：

![image-20231018125456613](https://gitee.com/chen-hao111222/images/raw/master/img/202312102216801.png)



#### 数据对象和关系：

- 行：[0,B1-1]	列：[0,B2-1]

![image-20231018125802465](https://gitee.com/chen-hao111222/images/raw/master/img/202312102216778.png)



#### 基本操作：

**没有插入和删除的操作**

1. 初始化
2. 销毁
3. 取值
4. 赋值

![image-20231018130152178](https://gitee.com/chen-hao111222/images/raw/master/img/202312102217826.png)



#### 数组的顺序存储：

一般用顺序存储结构，不用链式存储的原因是不执行插入和删除的操作，多维数组存储的内存单元是一维的

![image-20231018130449727](https://gitee.com/chen-hao111222/images/raw/master/img/202312102217574.png)



##### 一维存储：

```c
//创建一个空间为5的数组0-4
int a[5];
//首地址为2000个字节，每个元素占L=4个字节
//当求a[3]的地址的时候：3*4+2000=2012
//设求第i个元素的地址，则在i前面有i个元素,每个元素占L个字节，首地址为p
i地址=i*L+p
```

![image-20231018130933503](https://gitee.com/chen-hao111222/images/raw/master/img/202312102217192.png)



##### 二维存储：

二维数组可以看成由多个一维数组组成的，**每一行/列都可以是一个数组**

![image-20231018131521180](https://gitee.com/chen-hao111222/images/raw/master/img/202312102217786.png)



###### 以行序为主序：

把多维数组看成一个一维数组之后进行排序

![image-20231018131741426](https://gitee.com/chen-hao111222/images/raw/master/img/202312102217226.png)



###### 以列序为主序：

![image-20231018131858825](https://gitee.com/chen-hao111222/images/raw/master/img/202312102217491.png)

![image-20231018132023339](https://gitee.com/chen-hao111222/images/raw/master/img/202312102217517.png)



###### 行序优先表示：

![image-20231018132339118](https://gitee.com/chen-hao111222/images/raw/master/img/202312102217325.png)

求第i行第j列的元素的地址，【每行n个元素Xi行+第j列的位置】X字节数

##### 三维存储：

按照页/行/列存放顺序，页优先存放

看一个元素的地址，先看存在哪页，再看在哪行，最后看在哪一列

![image-20231018132927875](https://gitee.com/chen-hao111222/images/raw/master/img/202312102217802.png)

![image-20231018133627693](https://gitee.com/chen-hao111222/images/raw/master/img/202312102217141.png)



##### n维数组：

![image-20231018133726201](https://gitee.com/chen-hao111222/images/raw/master/img/202312102217659.png)



#### 例子：

![image-20231018134016043](https://gitee.com/chen-hao111222/images/raw/master/img/202312102217854.png)



### 4.4.3特殊矩阵的压缩存储：

**n阶矩阵=n行n列**

压缩：多个相同非零元素在同一个空间，零元素不分配空间

![image-20231018161607947](https://gitee.com/chen-hao111222/images/raw/master/img/202312102217315.png)

#### 举例可压缩矩阵：

![image-20231018162038397](https://gitee.com/chen-hao111222/images/raw/master/img/202312102217809.png)

##### 对称矩阵：

![image-20231018162459990](https://gitee.com/chen-hao111222/images/raw/master/img/202312102218217.png)

###### 位置查找：

当压缩之后存放在一个一维数组中，怎么找到第Aij个元素的地址呢？

需要找到第An1个元素存储在一维数组中的位置：

1. 先看在第n行，所以前面有n-1行的数值，(1+2+3+...+n-1)
2. 把上面的数值计算：(1+n-1)(n-1)/2

![image-20231018164457036](https://gitee.com/chen-hao111222/images/raw/master/img/202312102218338.png)



##### 三角矩阵：

![image-20231018165248188](https://gitee.com/chen-hao111222/images/raw/master/img/202312102218793.png)

##### 对角矩阵：

定义：处了对角线之外的元素都是零元素，如果为三对角矩阵，那么中间就有三条对角线 

![image-20231018165557873](https://gitee.com/chen-hao111222/images/raw/master/img/202312102218139.png)

###### 存储方式：

拿对角线来存放一个数组，以主对角线的长度的列位置为0

![image-20231018170146478](https://gitee.com/chen-hao111222/images/raw/master/img/202312102218402.png)



##### 稀疏矩阵：

![image-20231018171024814](https://gitee.com/chen-hao111222/images/raw/master/img/202312102218405.png)

###### 三元组存储举例：

以三元组的形式存储：存储元素在矩阵中的（行，列，值）三个值和矩阵维数几行几列和几个非零元素

![image-20231018171247763](https://gitee.com/chen-hao111222/images/raw/master/img/202312102218314.png)

![image-20231018171323836](https://gitee.com/chen-hao111222/images/raw/master/img/202312102218722.png)



###### 优缺点：

![image-20231018171500940](https://gitee.com/chen-hao111222/images/raw/master/img/202312102218354.png)



###### 十字链表存储举例：

两个指针域：

1. right：同行下一个非零元素
2. down：同列下一个非零元素

![image-20231018172710239](https://gitee.com/chen-hao111222/images/raw/master/img/202312102218449.png)

###### 存储过程：

![image-20231018174206215](https://gitee.com/chen-hao111222/images/raw/master/img/202312102218188.png)

![image-20231018174241900](https://gitee.com/chen-hao111222/images/raw/master/img/202312102218254.png)



## 4.5广义表：

广义表中可以有原子，也可以有广义表

![image-20231018174520802](https://gitee.com/chen-hao111222/images/raw/master/img/202312102218347.png)

###### 注意：

1. 表头：广义表的第一个原子
2. **表尾：除了表头之外的元素组成的子表**
3. 大写字母表示广义表，小写字母表示原子

![image-20231018174729058](https://gitee.com/chen-hao111222/images/raw/master/img/202312102218041.png)

###### 举例：

![image-20231018175122382](https://gitee.com/chen-hao111222/images/raw/master/img/202312102219282.png)

注意：

1. C=(a,(b,c))中表尾是**((b,c)**)，最外面的括号不能删除，如果删除了就表示错误
2. F=(a,F)是一个**递归广义表**，表示：F=(a,(a,(a,...)))



### 性质：

![image-20231018192728510](https://gitee.com/chen-hao111222/images/raw/master/img/202312102219721.png)

注意：

1. 长度：最外层所包含的元素的个数
2. **深度：**展开后所包含的括号的重数
   - C(((a)))——深度为3，因为有三重括号
3. 递归广义表：
   - 深度是无限的，因为不断的递归
   - 长度是有限的，看所含的个数

![image-20231018193348924](https://gitee.com/chen-hao111222/images/raw/master/img/202312102219561.png)



### 广义表和线性表的区别：

可以兼容线性表，数组，树，有向图等各种数据结构

![image-20231018193447728](https://gitee.com/chen-hao111222/images/raw/master/img/202312102219758.png)



### 基本运算：

注意看第三和第四第五个

![image-20231018193827686](https://gitee.com/chen-hao111222/images/raw/master/img/202312102219850.png)



## 4.6案例分析与实现：

![image-20231018194457462](https://gitee.com/chen-hao111222/images/raw/master/img/202312102219458.png)

![image-20231018194515256](https://gitee.com/chen-hao111222/images/raw/master/img/202312102219404.png)



# 第五章：树和二叉树

![image-20231018195433167](https://gitee.com/chen-hao111222/images/raw/master/img/202312101656278.png)

![image-20231018195519153](https://gitee.com/chen-hao111222/images/raw/master/img/202312101656191.png)



## 5.1.1树的定义

**树的定义是一个递归的定义**，树大多使用的是递归的方法，

![image-20231018195719300](https://gitee.com/chen-hao111222/images/raw/master/img/202312101656830.png)

![image-20231018195834698](https://gitee.com/chen-hao111222/images/raw/master/img/202312101656512.png)

###### 其他表示方法：

![image-20231018200321341](https://gitee.com/chen-hao111222/images/raw/master/img/202312101656448.png)

## 5.1.2 树的基本术语

![image-20231018201439770](https://gitee.com/chen-hao111222/images/raw/master/img/202312101656614.png)

### 概念介绍：

1. 根节点：非空树中**没有前驱结点**的结点
2. 叶子结点：没有后继的结点，度为0
3. 结点的度：一个结点拥有的分支
4. 树的度：一个**树中所有结点**的度的**最大值**
5. 树的深度：树中结点的**最大层次**，上面的树，深度为4

树的**度**和**深度**两个不同概念：

- 度为结点的分支树
- 深度为从根到最底层的叶子的**层数**



![image-20231018202200604](https://gitee.com/chen-hao111222/images/raw/master/img/202312101657344.png)

### 森林的概念：

**一颗树也是森林**

![image-20231018202445783](https://gitee.com/chen-hao111222/images/raw/master/img/202312101657944.png)



### 树和线性结构的比较：

![image-20231018202754758](https://gitee.com/chen-hao111222/images/raw/master/img/202312101657408.png)





## 5.1.3 二叉树的定义

普通树很难用算法实现，但是都能转为唯一对应的二叉树，这样就更方便实现

![image-20231018202943927](https://gitee.com/chen-hao111222/images/raw/master/img/202312101657808.png)

![image-20231018203204066](https://gitee.com/chen-hao111222/images/raw/master/img/202312101657454.png)

二叉树的结点可以为空，但是不能不区分左右位置

![image-20231018203409230](https://gitee.com/chen-hao111222/images/raw/master/img/202312101657478.png)



###### 思考：

![image-20231018203601574](https://gitee.com/chen-hao111222/images/raw/master/img/202312101657791.png)

### 树的5种基本形态：

![image-20231018203734696](https://gitee.com/chen-hao111222/images/raw/master/img/202312101657087.png)



## 5.2 应用案例

![image-20231018203942622](https://gitee.com/chen-hao111222/images/raw/master/img/202312101657767.png)

![image-20231018204108124](https://gitee.com/chen-hao111222/images/raw/master/img/202312101657015.png)



## 5.3数据类型定义

1. 树:具有相同特性的数据元素
2. 子树之间没有交集

![image-20231018204327575](https://gitee.com/chen-hao111222/images/raw/master/img/202312101658128.png)



### 几个重要的基本操作

![image-20231018204815283](https://gitee.com/chen-hao111222/images/raw/master/img/202312101658246.png)

```c
//新建一个二叉树，按先序次序输入二叉树中的结点的值
CreateBiTree(&T, definition)
//下面都是采用二叉链表存储结构
//先序遍历
PreOrderTraverse(T)
//中序遍历
InOrderTraverse(T)
//后序遍历
PostOrderTraverse(T)
//层序遍历
LeveOrderTraverse(T)
```





## 5.4二叉树的性质：

第i层上：

1. 第i层上至多有2^i-1个结点
2. 最少有i个结点

### 性质1：至多至少结点数

![image-20231021085336141](https://gitee.com/chen-hao111222/images/raw/master/img/202312101658433.png)



### 性质2：深度为k的二叉树结点总数

如果深度为k则二叉树最少也要有k个结点

![image-20231021085737487](https://gitee.com/chen-hao111222/images/raw/master/img/202312101658661.png)

### 性质3：叶子结点数

叶子结点：没有后继结点的结点

**叶子节点数=深度为2的结点数+1**

![image-20231021091354578](https://gitee.com/chen-hao111222/images/raw/master/img/202312101658086.png)



## 满二叉树：

最大结点，叶子都在底层，上下左右编号

![image-20231021091851825](https://gitee.com/chen-hao111222/images/raw/master/img/202312101658112.png)



![image-20231021092020643](https://gitee.com/chen-hao111222/images/raw/master/img/202312101658711.png)

## 完全二叉树：

**完全二叉树**的**结点序号**和**满二叉树**的一一对应

满二叉树从最后一个结点开始**连续去掉任意**的结点就是完全二叉树

![image-20231021092140263](https://gitee.com/chen-hao111222/images/raw/master/img/202312101658064.png)

![image-20231021092300638](https://gitee.com/chen-hao111222/images/raw/master/img/202312101658566.png)

![image-20231021092446817](https://gitee.com/chen-hao111222/images/raw/master/img/202312101658414.png)



### 性质4：n个结点的完全二叉树和深度的关系

完全二叉树**结点数n**和完全二叉树**深度K**之间的关系

![image-20231021092741705](https://gitee.com/chen-hao111222/images/raw/master/img/202312101659200.png)



### 性质5：用深度或者编号找到一个结点的父结点和兄弟结点

![image-20231021093006664](https://gitee.com/chen-hao111222/images/raw/master/img/202312101659359.png)



## 二叉树的顺序存储：

按照编号顺序来进行顺序存储

![image-20231021093433073](https://gitee.com/chen-hao111222/images/raw/master/img/202312101659041.png)

![image-20231021093627304](https://gitee.com/chen-hao111222/images/raw/master/img/202312101659025.png)



当一个树既不是满二叉树又不是完全二叉树的时候

![image-20231021093840873](https://gitee.com/chen-hao111222/images/raw/master/img/202312101659086.png)



### 缺点：

太多的空的结点，导致浪费空间，**树的顺序存储结构适合满二叉树和完全二叉树**

![image-20231021094202209](https://gitee.com/chen-hao111222/images/raw/master/img/202312101659896.png)



## 二叉树的链式存储：

二叉链表和三叉链表的区别在于**三叉链表有指向父结点的指针**

### 二叉链表：

有三个值：data自身的数据，还有指向另外左右孩子的指针

![image-20231021094816769](https://gitee.com/chen-hao111222/images/raw/master/img/202312101659782.png)

![image-20231021095108789](https://gitee.com/chen-hao111222/images/raw/master/img/202312101659777.png)

```c
typedef struct BiNode{
    TElemType data;
    struct BiNode *lchild, *rchild;//指向左右孩子的指针，指针类型和定义的相同
}BiNode, *BiTree;
```

如果没有子结点，则指针域为空

![image-20231021095236285](https://gitee.com/chen-hao111222/images/raw/master/img/202312101659105.png)

###### 判断有n个结点的二叉链表中有多少个空指针域

![image-20231021095536391](https://gitee.com/chen-hao111222/images/raw/master/img/202312101700689.png)



### 三叉链表：

![image-20231021095747279](https://gitee.com/chen-hao111222/images/raw/master/img/202312101700218.png)



## 5.5.1 二叉树的遍历：

遍历：得到所有结点的一个线性排列

![image-20231021100039479](https://gitee.com/chen-hao111222/images/raw/master/img/202312101700171.png)



### 算法描述：

1. 先序遍历：根左右
2. 中序遍历：左根右
3. 后序遍历：左右根

![image-20231021100331094](https://gitee.com/chen-hao111222/images/raw/master/img/202312101700081.png)



![image-20231021100607533](https://gitee.com/chen-hao111222/images/raw/master/img/202312101700395.png)



#### 先序遍历：根左右

先序遍历时需要把左右分为两部分，需要把左结点按照根左右遍历完才能遍历右结点

![image-20231021101026669](https://gitee.com/chen-hao111222/images/raw/master/img/202312101700800.png)



#### 中序遍历：左中右

方法：在遍历右边分支的时候，也是需要从最下面的左（M）开始

![image-20231021101338429](https://gitee.com/chen-hao111222/images/raw/master/img/202312101700017.png)



### 例题：

![image-20231021104911646](https://gitee.com/chen-hao111222/images/raw/master/img/202312101700593.png)

### 数学表达式：

中序遍历时是正常的表达式

![image-20231021105055059](https://gitee.com/chen-hao111222/images/raw/master/img/202312101700680.png)





### 根据遍历序列确定二叉树：

**有先中和后中就可以找到二叉树，如果只有先后遍历序列就不可以**

![image-20231021105238628](https://gitee.com/chen-hao111222/images/raw/master/img/202312101700718.png)

#### 先中序列：

从中序中看到A为根结点，A左边的和右边分别为左右两部分的值，再从先序中判断子树的位置，从中序的左根右判断是左还是右分支

![image-20231021105919708](https://gitee.com/chen-hao111222/images/raw/master/img/202312101700768.png)

![image-20231021145510813](https://gitee.com/chen-hao111222/images/raw/master/img/202312101700511.png)

#### 中后序列：

![image-20231021151023464](https://gitee.com/chen-hao111222/images/raw/master/img/202312101701984.png)







### 先序遍历算法：

![image-20231021151756076](https://gitee.com/chen-hao111222/images/raw/master/img/202312101701673.png)

**用递归的方式来操作：**

![image-20231021151737836](https://gitee.com/chen-hao111222/images/raw/master/img/202312101701760.png)

```c
Status PreOrderTraverse(Bitree T){
    if(T==NULL) return OK;		//判断是否为空二叉树
    else{
        //先序遍历，先访问根结点
        visit(T);		//访问根结点
        PreOrderTraverse(T->lchild);	//递归遍历左子树
        PreOrderTraverse(T->rchild);	//递归遍历右子树
    }
}
```

每个结点都需要去访问，然后再返回，每次执行遍历结束才可以返回上一级

![image-20231021152451797](https://gitee.com/chen-hao111222/images/raw/master/img/202312101701046.png)



### 中序遍历算法：

![image-20231021152717828](https://gitee.com/chen-hao111222/images/raw/master/img/202312101701870.png)

和先序遍历差不多，都是需要先判断是否为空，但是中序遍历先递归遍历左子树的值，左中右

![image-20231021152758732](https://gitee.com/chen-hao111222/images/raw/master/img/202312101701950.png)

### 后续遍历算法：

![image-20231021152903897](https://gitee.com/chen-hao111222/images/raw/master/img/202312101701327.png)



![image-20231021152937418](https://gitee.com/chen-hao111222/images/raw/master/img/202312101701871.png)





### 三个对比分析：

![image-20231021153250844](https://gitee.com/chen-hao111222/images/raw/master/img/202312101701280.png)

###### 可以从经过的次数来判断遍历顺序：

![image-20231021153200754](https://gitee.com/chen-hao111222/images/raw/master/img/202312101701647.png)

![image-20231021153352698](https://gitee.com/chen-hao111222/images/raw/master/img/202312101701951.png)



### 中序遍历非递归算法：

用栈先进后出的性质来存储根结点，当访问完左结点后再输出

![image-20231021153622508](https://gitee.com/chen-hao111222/images/raw/master/img/202312101701128.png)

![image-20231021153855202](https://gitee.com/chen-hao111222/images/raw/master/img/202312101702503.png)

循环：当p指针和栈都为空时，就可以结束循环

当p为空，栈不为空时，则出栈执行下一次循环

![image-20231021154259124](https://gitee.com/chen-hao111222/images/raw/master/img/202312101702085.png)

```c
Status InOrderTraverse(BiTree T){
    BiTree p;
    InitStack(S);
    p=T;
    while(p || !StackEmpty(S)){
        if(p) {Push(S,p) p = p->lchild;}
        else {Pop(S,q); pirntf("%c" ,q->data); p = q->rchild;}
    }//while
    return OK;
}
```



### 二叉树的层次遍历：

用队列来遍历

![image-20231021154548699](https://gitee.com/chen-hao111222/images/raw/master/img/202312101702625.png)

![image-20231021154705419](https://gitee.com/chen-hao111222/images/raw/master/img/202312101702086.png)

###### 方法：

**先把父结点入队，看他是否有左右孩子，如果有，则把父结点出队，把其左右结点入队，从上到下，从左到右**

![image-20231021155055444](https://gitee.com/chen-hao111222/images/raw/master/img/202312101702726.png)

###### 算法：

![image-20231021155144225](https://gitee.com/chen-hao111222/images/raw/master/img/202312101702734.png)

![image-20231021155517649](https://gitee.com/chen-hao111222/images/raw/master/img/202312101702183.png)





### 建立二叉树：

如果仅知道序列，会有很多种不可能，如果要一个固定的二叉树，**就要把空的叶子替换为#**，**就可以得到唯一的一个树**

![image-20231022195558078](https://gitee.com/chen-hao111222/images/raw/master/img/202312101702583.png)



#### 算法：

如果输入#则表示树为空，如果创建空间失败，exit，如果创建成功把输入的之赋值给根结点，递归左右子树

![image-20231022200309057](https://gitee.com/chen-hao111222/images/raw/master/img/202312101702151.png)

```c
Status CreateRiTree(BiTree &T){
    scanf(&ch);		//输入数
    if(ch=="#") T=NULL;		//当输入#时表示结点为空
    else{
        if(!(T=(BiTNode *)malloc(sizeof(BiTNode))))
            eixt(OVERFLOW);		//如果超过了创建的空间则返回OVERFLOW
        T->data = ch;		//把输入的值赋值给数据域
        CreateBiTree(T->lchild);
        CreateBiTree(T->rchild);
    }
    return OK;
}//CreateBiTree
```



### 复制二叉树：

![image-20231022200844926](https://gitee.com/chen-hao111222/images/raw/master/img/202312101702785.png)



### 计算二叉树的深度：

先看根结点是否为空，如果为空则深度为0，如果不为空，则分别用递归调用本函数来计算左右子树的深度后加一，加上根结点的，然后比较左右结点深度的大小，取较大值

![image-20231022201346661](https://gitee.com/chen-hao111222/images/raw/master/img/202312101702144.png)



### 计算结点总数：

![image-20231022202445260](https://gitee.com/chen-hao111222/images/raw/master/img/202312101703991.png)



### 计算叶子结点数：

![image-20231022203812556](https://gitee.com/chen-hao111222/images/raw/master/img/202312101703840.png)



## 线索二叉树：

将二叉树的空子树**左边**指向**前驱**结点，**右边**指向**后继**结点，**按照遍历序列选择前后驱**

![image-20231022204218483](https://gitee.com/chen-hao111222/images/raw/master/img/202312101703999.png)



![image-20231022204335603](https://gitee.com/chen-hao111222/images/raw/master/img/202312101703160.png)



![image-20231022210636628](https://gitee.com/chen-hao111222/images/raw/master/img/202312101703239.png)

### 定义：左前右后

空的左右孩子指针，左孩子的指向其前驱，右孩子的指向其后继，0指向孩子，1指向前后驱

![image-20231022210856670](https://gitee.com/chen-hao111222/images/raw/master/img/202312101703838.png)

### 方法：

如果一个结点的左结点为空则使其指针域指向上一个结点，如果右结点为空，则使其指向下一个结点

![image-20231022211534235](https://gitee.com/chen-hao111222/images/raw/master/img/202312101703045.png)

0指向孩子，1指向前后驱

![image-20231022211942513](https://gitee.com/chen-hao111222/images/raw/master/img/202312101703911.png)

### 初始化结构：

![image-20231022212955833](https://gitee.com/chen-hao111222/images/raw/master/img/202312101703992.png)

#### 先序线索二叉树：

![image-20231022213131578](https://gitee.com/chen-hao111222/images/raw/master/img/202312101703839.png)

#### 中序线索二叉树：

![image-20231022213244066](https://gitee.com/chen-hao111222/images/raw/master/img/202312101703487.png)

#### 后序线索二叉树：

![image-20231022213315082](https://gitee.com/chen-hao111222/images/raw/master/img/202312101703016.png)



###### **增加一个头结点：**

**头结点的头指针指向根结点，尾指针指向最后一个结点，第一个遍历的结点前指针为空指向头指针，最后一个结点的后指针为空，指向头结点的尾指针**

![image-20231022213555348](https://gitee.com/chen-hao111222/images/raw/master/img/202312101704359.png)





## 森林：

![image-20231022213943691](https://gitee.com/chen-hao111222/images/raw/master/img/202312101704719.png)



## 双亲结点表示法：

双亲结点的指针域数值的意思是数组元素的下标

![image-20231022214405116](https://gitee.com/chen-hao111222/images/raw/master/img/202312101704599.png)

### 算法描述：

![image-20231022215617528](https://gitee.com/chen-hao111222/images/raw/master/img/202312101704885.png)



## 孩子链表：

每个结点的孩子都分别放在一个线性表中，然后再把树的每个结点都存储在一个数组中，然后数组中的每个结点都可以指向自己的孩子线性表

![image-20231022215937787](https://gitee.com/chen-hao111222/images/raw/master/img/202312101704671.png)



### 算法描述：

双亲结点的指针指向孩子所在的链表，

![image-20231022220359328](https://gitee.com/chen-hao111222/images/raw/master/img/202312101704511.png)





## 带双亲的孩子链表：

红色那一列就是**自己的双亲的序号**，使得可以方便的找到双亲

![image-20231022220731953](https://gitee.com/chen-hao111222/images/raw/master/img/202312101704137.png)



## 孩子兄弟表示法：

![image-20231022221135235](https://gitee.com/chen-hao111222/images/raw/master/img/202312101704113.png)

如果要找到一个结点的孩子，就只需要顺着孩子指针找，需要找到一个结点的兄弟指针，则需要顺着兄弟指针一直找就可以了

![image-20231022221442748](https://gitee.com/chen-hao111222/images/raw/master/img/202312101704871.png)



## 树和二叉树之间的转换：

把树的**兄弟结点**转换为二叉树的**右孩子结点**

![image-20231022222201259](https://gitee.com/chen-hao111222/images/raw/master/img/202312101704631.png)



### 树—>二叉树的方法：

![image-20231022222437164](https://gitee.com/chen-hao111222/images/raw/master/img/202312101704582.png)

#### 例子：

![image-20231022222633602](https://gitee.com/chen-hao111222/images/raw/master/img/202312101704096.png)



### 二叉树—>树的方法：

![image-20231022222859138](https://gitee.com/chen-hao111222/images/raw/master/img/202312101704557.png)

#### 例子：

![image-20231022223028781](https://gitee.com/chen-hao111222/images/raw/master/img/202312101705719.png)



## 森林—>二叉树方法：

![image-20231022223325738](https://gitee.com/chen-hao111222/images/raw/master/img/202312101705927.png)



### 例子：

![image-20231022223720668](https://gitee.com/chen-hao111222/images/raw/master/img/202312101705559.png)



## 二叉树—>森林的方法：

![image-20231022223930762](https://gitee.com/chen-hao111222/images/raw/master/img/202312101705703.png)



### 例子：

![image-20231022224001449](https://gitee.com/chen-hao111222/images/raw/master/img/202312101705918.png)



## 5.6.3 树的遍历

先根的意思是，先输出根然后再输出孩子

后根的意思是，从根的第一个孩子的第一个孩子。。。

![image-20231022224329193](https://gitee.com/chen-hao111222/images/raw/master/img/202312101705406.png)



## 5.6.4 森林的遍历：

![image-20231022224749666](https://gitee.com/chen-hao111222/images/raw/master/img/202312101705527.png)





### 森林先序遍历：

![image-20231022224928369](https://gitee.com/chen-hao111222/images/raw/master/img/202312101705750.png)



### 森林中序遍历：

![image-20231022225042865](https://gitee.com/chen-hao111222/images/raw/master/img/202312101705697.png)



先和中对比：都是同样的三个部分，但是顺序不同，

例子：

![image-20231022225541050](https://gitee.com/chen-hao111222/images/raw/master/img/202312101705935.png)



## 5.7.1 哈夫曼树

#### 判断树：

![image-20231023160105392](https://gitee.com/chen-hao111222/images/raw/master/img/202312101706647.png)

#### 提高判别树效率

![image-20231023160451660](https://gitee.com/chen-hao111222/images/raw/master/img/202312101706959.png)



### 基本概念：

#### 结点的路径长度：

![image-20231023160843251](https://gitee.com/chen-hao111222/images/raw/master/img/202312101706591.png)



#### 树的路径长度：

所有路径相加

![image-20231023161128568](https://gitee.com/chen-hao111222/images/raw/master/img/202312101706518.png)



#### 树的带权路径长度：

就是一个树的**全部叶子结点**的带权路径长度之和

![image-20231023161616583](https://gitee.com/chen-hao111222/images/raw/master/img/202312101706495.png)



##### 例子：

![image-20231023161718495](https://gitee.com/chen-hao111222/images/raw/master/img/202312101706846.png)





#### 最优二叉树：

就是效率最高的二叉树，**带权路径最短的树**——哈夫曼树

![image-20231023161956231](https://gitee.com/chen-hao111222/images/raw/master/img/202312101706567.png)



##### 例子：

1. 满二叉树不一定是哈夫曼树
2. 哈夫曼树：带权路径长度最短的二叉树
3. 哈夫曼树中**权越大的叶子离根越近**，权值比较大的离根比较近，权值小的离根比较远
4. 具有相同的带权结点的哈夫曼树不唯一

![image-20231023162731347](https://gitee.com/chen-hao111222/images/raw/master/img/202312101706733.png)



## 5.7.2 哈夫曼树的构造算法：

![image-20231023163306354](https://gitee.com/chen-hao111222/images/raw/master/img/202312101706359.png)



### 贪心算法：

构造哈夫曼树时首先选择权值较小的叶子结点相结合



### 构造方法：

![image-20231023163622203](https://gitee.com/chen-hao111222/images/raw/master/img/202312101706024.png)

### 注意点：

1. 先把每个结点构造成根，再把两个最小的根构造一个新树**左小右大**，然后根的权值为两个结点的权值相加
2. 哈夫曼树的**结点的度**：只有0和2，没有度为1的结点
3. 包含**n个叶子结点**的哈夫曼树共有**2n-1个结点**
4. 包含n棵树的森林要**经过n-1次合并**才能形成哈夫曼树，共产生n-1个新结点

#### 例子：

![image-20231023164357257](https://gitee.com/chen-hao111222/images/raw/master/img/202312101706831.png)

![image-20231023164907243](https://gitee.com/chen-hao111222/images/raw/master/img/202312101706060.png)



### 哈夫曼树合并总结：

![image-20231023165047710](https://gitee.com/chen-hao111222/images/raw/master/img/202312101707992.png)

**哈夫曼树中有n个度为0的结点，有n-1个度为2的结点**



### 算法实现：

![image-20231023170649509](https://gitee.com/chen-hao111222/images/raw/master/img/202312101707895.png)



#### 建立哈夫曼树的算法过程：

![image-20231023171034195](https://gitee.com/chen-hao111222/images/raw/master/img/202312101707095.png)



##### 初始化哈夫曼树：

![image-20231023171145191](https://gitee.com/chen-hao111222/images/raw/master/img/202312101707632.png)

![image-20231023171243357](https://gitee.com/chen-hao111222/images/raw/master/img/202312101707360.png)

```c
void CreatHuffmanTree(HuffmanTree HT, int n){
    if(n<=1) return;
    m=2*n-1;	//数组共2n-1个元素
    HT = new HTNode[m+1];	//0号单元未用，HT[m]表示根结点
    for(i=1;i<=m;++i){
        //将所有结点的指针域都置零
        HT[i].lch=0;	HT[i].rch=0;	HT[i].parent=0;
    }
    for(i=1;i<=n;++i)	cin>>HT[i].weight;		//输入前n个元素的weight值
}
```



##### 合并两个结点：

1. 选择两个权值最小的根结合
2. 修改这两个结点的父指针为i
3. 修改i结点的权值为两个的相加，同时添加为i的左右结点

![image-20231023171551036](https://gitee.com/chen-hao111222/images/raw/master/img/202312101707952.png)

![image-20231023172019525](https://gitee.com/chen-hao111222/images/raw/master/img/202312101707503.png)

```c
for(i=n+1;i<=m;i++){	//合并产生n-1个结点，构造哈夫曼树
    select(HT, i-1, s1, s2);	//在HT[k]中选择两个双亲域为0且权值最小的结点，返回他们的HT中的序号
    //这两个结点的父指针指向i结点
    HT[s1].parent=i;
    HT[s2].parent=i;
    //i结点的左右指针指向
    HT[i].lch=s1;
    HT[i].rch=s2;
    //i结点的权值
    HT[i].weight=HT[s1].weight + HT[s2].weight;
}
```



## 5.7.3 哈夫曼编码：

![image-20231026085015711](https://gitee.com/chen-hao111222/images/raw/master/img/202312101707310.png)



### 例子：

先按权值形成一个哈夫曼树，然后**左数写0右数写1**，形成编码输出

![image-20231026085232826](https://gitee.com/chen-hao111222/images/raw/master/img/202312101707830.png)



### 结论：

**所有字符都在叶子结点**，所以互不干扰，所以能爆炸是前缀编码

![image-20231026085532236](https://gitee.com/chen-hao111222/images/raw/master/img/202312101707303.png)



### 算法实现：

![image-20231026090532096](https://gitee.com/chen-hao111222/images/raw/master/img/202312101707511.png)

 

![image-20231026090550647](https://gitee.com/chen-hao111222/images/raw/master/img/202312101707687.png)

```c
void CreatHuffmanCode(HuffmanTree HT, HuffmanCode &HC, int n){
    //从叶子结点到根逆向求每个字符的哈夫曼编码，存储在编码表中
    HC = new char *[n+1];	//分配n个字符编码的头指针矢量
    cd = new char [n];		//分配临时存放编码的动态数组空间
    cd[n-1] = '\0';		//编码结束符
    for(i=1;i<=n;++i){		//逐个字符求哈夫曼编码
        start = n-1;	
        c=i;
        f = HT[i].parent;
        while(f!=0){		//从叶子结点开始向上回溯，直到根结点
            --start;		//回溯一次start向前指一个位置
            //左0右1
            if (HT[f].lchild == c)	cd[start]='0';	//左孩子赋值0
            else	cd[start]='1';					//结点是右孩子就赋值1
         	c=f;f=HT[f].parent;		//继续向上回溯
        }		//求出第i个字符串编码分配空间
        HC[i]=new char[n-start];
        strcpy(HC[i],&cd[start]);	//将求得的编码从临时空间cd复制到HC的当前行中
    }
    delete cd;		//释放临时空间
}
```





# 第六章—图：

## 6.1图的定义和术语：

![image-20231101201303081](https://gitee.com/chen-hao111222/images/raw/master/img/202312101708446.png)

![image-20231101201450911](https://gitee.com/chen-hao111222/images/raw/master/img/202312101428954.png)

1. 弧：表示的是有向图的边，弧就是有方向的边
2. **(Vi,Vj)**：表示两个没有关系的边，无序的
3. **<VI,Vj>**：表示两个边有方向关系，有序的

![image-20231101202141102](https://gitee.com/chen-hao111222/images/raw/master/img/202312101428506.png)

度：和该顶点关联的边的数目

出入度：只有有向图有，因为有向图有弧是有方向的，以顶点为起点为出度，以顶点为终点的为入度

![image-20231101202843593](https://gitee.com/chen-hao111222/images/raw/master/img/202312101428713.png)



![image-20231101203406046](https://gitee.com/chen-hao111222/images/raw/master/img/202312101429130.png)

1. 环（回路）：起点和终点相同的路径
2. 简单路径：顶点不会重复
3. 简单回路：形成一个环，途中顶点不重复



![image-20231101203802286](https://gitee.com/chen-hao111222/images/raw/master/img/202312101429681.png)

###### 连通图：

![image-20231101204300253](https://gitee.com/chen-hao111222/images/raw/master/img/202312101430433.png)

###### 权和网：

![image-20231101204419022](https://gitee.com/chen-hao111222/images/raw/master/img/202312101433106.png)

###### 子图：

![image-20231101204557183](https://gitee.com/chen-hao111222/images/raw/master/img/202312101433593.png)

###### 极大连通子图：

![image-20231101204804054](https://gitee.com/chen-hao111222/images/raw/master/img/202312101433128.png)

###### 强连通分量：

把非强连通的图分为部分子图，使其变为强连通分量

![image-20231101205149428](https://gitee.com/chen-hao111222/images/raw/master/img/202312101434722.png)

###### 极小连通子图：

连通图删除一些边之后，直到再删除一条边就不能形成连通图之前的就是极小连通图

![image-20231101205513478](https://gitee.com/chen-hao111222/images/raw/master/img/202312101434712.png)

## 6.3 图的类型定义：

![image-20231101205913439](https://gitee.com/chen-hao111222/images/raw/master/img/202312101452250.png)

### 基础操作：

![image-20231101205936761](https://gitee.com/chen-hao111222/images/raw/master/img/202312101452802.png)

![image-20231101210036407](https://gitee.com/chen-hao111222/images/raw/master/img/202312101452474.png)



## 6.4图的存储结构：

没有顺序存储，可以用二维数组来表示关系

![image-20231101210317135](https://gitee.com/chen-hao111222/images/raw/master/img/202312101453875.png)

## 6.4.1 邻接矩阵（数组表示法）：

![image-20231101210720028](https://gitee.com/chen-hao111222/images/raw/master/img/202312101454546.png)

#### 无向图的表示：

1. 无向图的邻接矩阵是对称的，且对角线都为0
   - 对角线都为0：因为在无向图中自己对自己没有边
   - 对称：因为两个顶点间有边的时候可以互通
2. 完全图中的对角的元素为0，其余为1，因为每个顶点都连通

![image-20231101215633534](https://gitee.com/chen-hao111222/images/raw/master/img/202312101515064.png)



#### 有向图的表示：

矩阵中的记录需要分出度和入度来记，**列记入度，行记出度**

记录的顺序：看每个顶点作为起点到另外一个顶点

![image-20231101220251652](https://gitee.com/chen-hao111222/images/raw/master/img/202312101515291.png)



#### 有向网的表示：

和有向图的记录方式差不多，但是二维数组中记录的是权值，若没有边则记录无穷

![image-20231101220648523](https://gitee.com/chen-hao111222/images/raw/master/img/202312101515435.png)

### 初始化邻接矩阵：

![image-20231101221151290](https://gitee.com/chen-hao111222/images/raw/master/img/202312101515834.png)

```c
#define Maxlnt 2893798		//极大值
#define MVNum 100;			//最大顶点数
typedef char VerTexType;	//设顶点的数据类型为字符型
typedef int ArcType;		//假设边的权值类型为整型
typedef struct{
    VerTexType vexs[MVNum];	//顶点表
    ArcType arcs[MVNum][MVNum];	//邻接矩阵
    int vexnum, arcnum;		//图的当前点数和边数
}AMGraph;	//Adjacency Matrix Graph
```

### 构造无向网邻接矩阵：

![image-20231101221830529](https://gitee.com/chen-hao111222/images/raw/master/img/202312101517489.png)

#### 算法：

![image-20231101222016976](https://gitee.com/chen-hao111222/images/raw/master/img/202312101527130.png)

![image-20231101222158943](https://gitee.com/chen-hao111222/images/raw/master/img/202312101527304.png)

![image-20231101222359233](https://gitee.com/chen-hao111222/images/raw/master/img/202312101527934.png)

```c
Starus CreateUDN(AMGraph &G){
    cin>>G.vexnum>>G.arcnum;	//输入总顶点数，总边数
    for (i = 0; i<G.vexnum; ++i)
        cin>>G.vexs[i];		//输入点的信息
    for (i = 0; i<G.vexnum; ++i)	//初始化邻接矩阵
        for (j = 0; j<G.vexnum; ++j)
            G.arcs[i][j] = MaxInt;	//边的权值均置为极大值
    for (k = 0; k<G.arcnum; ++k){	//构造邻接矩阵
        cin>>v1>>v2>>w;		//输入一条边所依附的顶点及边的权值
        i = LocateVex(G, v1);		
        j = LocateVex(G, v2);	//确定v1和v2在G中的位置
        G.arcs[i][j] = w;		//边<v1,v2>的权值置为w
        G.arcs[j][i] = G.arcs[i][j];	//置<v1,v2>的对称边<v2,v1>的权值为w
    }//for
    return OK;
}//CreateUDN
int LocateVex(AMGraph G, VertexType u){
    int i;
    for (i = 0; i<G.vexnum; ++i)
        if (u==G.vexs[i])	return i;
    return -1;
}
```



### 构建无向图和有向图：

![image-20231101222734284](https://gitee.com/chen-hao111222/images/raw/master/img/202312101548499.png)



### 邻接矩阵的优缺点：

![image-20231101223039251](https://gitee.com/chen-hao111222/images/raw/master/img/202312101548129.png)

![image-20231101223140177](https://gitee.com/chen-hao111222/images/raw/master/img/202312101548434.png)



## 邻接矩阵（链式表示法）：

info：表示存储边权值

![image-20231101223705289](https://gitee.com/chen-hao111222/images/raw/master/img/202312101548329.png)

![image-20231101223628573](https://gitee.com/chen-hao111222/images/raw/master/img/202312101548665.png)

![image-20231101223642407](https://gitee.com/chen-hao111222/images/raw/master/img/202312101548138.png)

#### 无向图的表示：

![image-20231101224000488](https://gitee.com/chen-hao111222/images/raw/master/img/202312101549248.png)

#### 有向图的表示：

根据需要出度边还是入度边来选择，如果没有相应的出或入度的边则==NULL

![image-20231101224416897](https://gitee.com/chen-hao111222/images/raw/master/img/202312101552056.png)



## 练习：

![image-20231101224708545](https://gitee.com/chen-hao111222/images/raw/master/img/202312101557851.png)



## 6.4.2 邻接表：

### 顶点的结点结构：

顶点的信息的数据类型要看顶点的值是什么来定义

![image-20231102083709332](https://gitee.com/chen-hao111222/images/raw/master/img/202312101557007.png)

### 边的结点的结构：

![image-20231102083909975](https://gitee.com/chen-hao111222/images/raw/master/img/202312101557486.png)

### 图的结构定义：

![image-20231102084137012](https://gitee.com/chen-hao111222/images/raw/master/img/202312101557353.png)

### 邻接表的操作举例：

![image-20231102084546188](https://gitee.com/chen-hao111222/images/raw/master/img/202312101641043.png)



### 构造无向网（邻接表法）：

用头插法来创建邻接表，先找到每条边的两个顶点，确定两个顶点在数组中的下标序号，再分别插入到两个顶点的边结点的链表头部

![image-20231102084859613](https://gitee.com/chen-hao111222/images/raw/master/img/202312101641680.png)



#### 算法过程：

![image-20231102085314609](https://gitee.com/chen-hao111222/images/raw/master/img/202312101641071.png)

如果是有向网就只需要建立一条边就好了，看是出或入度来选择建立，

![image-20231102085620703](https://gitee.com/chen-hao111222/images/raw/master/img/202312101642216.png)



### 邻接表的特点：

![image-20231102090321683](https://gitee.com/chen-hao111222/images/raw/master/img/202312101641144.png)





### 邻接矩阵和邻接表对比：

![image-20231102090510174](https://gitee.com/chen-hao111222/images/raw/master/img/202312101650889.png)

![image-20231102090810162](https://gitee.com/chen-hao111222/images/raw/master/img/202312101650022.png)



### 十字链表和邻接多重表：

![image-20231102090952568](https://gitee.com/chen-hao111222/images/raw/master/img/202312101650960.png)



![image-20231102091514087](https://gitee.com/chen-hao111222/images/raw/master/img/202312101650871.png)



#### 十字链表：

过程：先找每个顶点的出入度的弧，分别指向，**顶点结点**多增加了一个指针域用来**指向入度的边结点**，**弧结点**增加了两个域用来指向作为**头和尾的顶点的序号**

![image-20231102092135597](https://gitee.com/chen-hao111222/images/raw/master/img/202312101650233.png)





#### 无向图的邻接多重表：

无向图的边需要存储两个方向的边，如果要删除边的话就要删除两个边，很麻烦

![image-20231102092650087](https://gitee.com/chen-hao111222/images/raw/master/img/202312101650862.png)

1. 每两个顶点间的边只需要记录一次就好了，画在哪里不重要
2. 更方便的找到一个结点的所有边，方便算度的值

![image-20231102093325381](https://gitee.com/chen-hao111222/images/raw/master/img/202312101651816.png)





## 6.5 图的遍历：

遍历所有顶点，且每个顶点只能访问一次

![image-20231102093600286](https://gitee.com/chen-hao111222/images/raw/master/img/202312101651367.png)

为防止重复访问可以建立一个数组，来存放一个顶点被访问过的次数

![image-20231102093738011](https://gitee.com/chen-hao111222/images/raw/master/img/202312101651375.png)







### 深度优先遍历（DFS）：

选择一条路一直走到底，到底后逐个顶点返回再寻找没有被访问过的顶点，然后再一个一个返回到起点处

![image-20231102094233877](https://gitee.com/chen-hao111222/images/raw/master/img/202312101651088.png)

看选择的顶点不同，则遍历序列可以不同

![image-20231102094454022](https://gitee.com/chen-hao111222/images/raw/master/img/202312101651184.png)

#### 算法实现：

![image-20231102094800115](https://gitee.com/chen-hao111222/images/raw/master/img/202312101651887.png)



![image-20231102094955389](https://gitee.com/chen-hao111222/images/raw/master/img/202312101651897.png)



#### DFS算法效率分析：

![image-20231102105053263](https://gitee.com/chen-hao111222/images/raw/master/img/202312101651080.png)





#### 非连通图的深度遍历：

和连通图差不多，但是非连通的子图部分留在最后

![image-20231102105433087](https://gitee.com/chen-hao111222/images/raw/master/img/202312101651791.png)



### 广度优先遍历（BFS）

对每个顶点的子树进行遍历，每一层逐个遍历

![image-20231102110437913](https://gitee.com/chen-hao111222/images/raw/master/img/202312101652632.png)

#### 非连通的广度遍历：

![image-20231102110717242](https://gitee.com/chen-hao111222/images/raw/master/img/202312101652250.png)



#### 实现：

用一个队列来实现顺序，先把根入队，然后逐个把其分支子树入队，每个子树的子树分别入队，一层一层来遍历

![image-20231106161204474](https://gitee.com/chen-hao111222/images/raw/master/img/202312101652759.png)

#### 算法：

![image-20231106161915528](https://gitee.com/chen-hao111222/images/raw/master/img/202312101652270.png)



![image-20231106162054517](https://gitee.com/chen-hao111222/images/raw/master/img/202312101652319.png)

![image-20231106162217607](https://gitee.com/chen-hao111222/images/raw/master/img/202312101652705.png)





## 6.6 图的应用

### 1、生成树：

![image-20231106162808733](https://gitee.com/chen-hao111222/images/raw/master/img/202312101652263.png)

顶点数和边反过来后的树：

![image-20231106162954268](https://gitee.com/chen-hao111222/images/raw/master/img/202312101652840.png)

### 2、无向图的生成树：

把顶点和用深度优先遍历的过程中的边结合起来就是生成树

![image-20231106163347615](https://gitee.com/chen-hao111222/images/raw/master/img/202312101652608.png)



### 3、无向网 最小生成树：

权值之和最小的路径就是最小代价生成树

![image-20231106163707468](https://gitee.com/chen-hao111222/images/raw/master/img/202312101652511.png)

![image-20231106163905616](https://gitee.com/chen-hao111222/images/raw/master/img/202312101653302.png)



### 4、MST构造最小生成树：

顶点集的一个**非空子集u和顶点集v**间一条**最小权值的边**，一定出现再一个最小生成树中

![image-20231106165048948](https://gitee.com/chen-hao111222/images/raw/master/img/202312101653976.png)

加上权值最小的边之后不能有回路

![image-20231106165504466](https://gitee.com/chen-hao111222/images/raw/master/img/202312101653581.png)



### 5、构造最小生成树的方法：

#### 普里姆算法：

所有顶点的集合V，先把顶点选出为集合U，然后找和V-U可以相连的最小权值的边连接后把这个顶点加入到U集合，然后逐个找两个集合间可以相连的权值最小的边

![image-20231106170108752](https://gitee.com/chen-hao111222/images/raw/master/img/202312101653535.png)



#### 克鲁斯卡尔算法：

一开始只要所有顶点不要边，然后逐个把最小权值的边连接，如果连接的时候形成回路则舍弃重新选择，直到所有顶点都连接到，有可能会出现最小生成树不唯一的情况

![image-20231106170901353](https://gitee.com/chen-hao111222/images/raw/master/img/202312101653135.png)



#### 两个算法比较：

![image-20231106171250462](https://gitee.com/chen-hao111222/images/raw/master/img/202312101653887.png)



### 6、最短路径：

![image-20231106171710503](https://gitee.com/chen-hao111222/images/raw/master/img/202312101653007.png)

![image-20231106171838148](https://gitee.com/chen-hao111222/images/raw/master/img/202312101653055.png)

![image-20231106172431545](https://gitee.com/chen-hao111222/images/raw/master/img/202312101653975.png)

#### 两点间最短路径：

![image-20231106171949908](https://gitee.com/chen-hao111222/images/raw/master/img/202312101653478.png)

#### 某源点到其他各点最短路径：

![image-20231106172127976](https://gitee.com/chen-hao111222/images/raw/master/img/202312101653847.png)



### 7、单源最短路径——Dijistra算法：

每次以一个顶点为源点，重复执行算法N次

![image-20231106192009886](https://gitee.com/chen-hao111222/images/raw/master/img/202312101654614.png)

![image-20231106192156012](https://gitee.com/chen-hao111222/images/raw/master/img/202312101654191.png)

#### 算法步骤：

先找所有能直达顶点的各个顶点的边，然后再选出最小权值的边把这个顶点加入到V0顶点的集合中再继续看是否有更小的权值路径

![image-20231106193428128](https://gitee.com/chen-hao111222/images/raw/master/img/202312101654743.png)





### 8、弗洛伊德算法：

![image-20231106194136660](https://gitee.com/chen-hao111222/images/raw/master/img/202312101654655.png)

![image-20231106194814348](https://gitee.com/chen-hao111222/images/raw/master/img/202312101654544.png)



### 9、 有向无环图：

有方向的边，一个子树有多个父树

![image-20231106195003797](https://gitee.com/chen-hao111222/images/raw/master/img/202312101654343.png)

### 10、AOV网（拓扑排序）

顶点表示活动，弧表示活动间的制约关系

#### 介绍：

![image-20231106201110381](https://gitee.com/chen-hao111222/images/raw/master/img/202312101654277.png)

#### 特点：

![image-20231106201046752](https://gitee.com/chen-hao111222/images/raw/master/img/202312101654396.png)

#### 拓扑排序：

![image-20231106201311870](https://gitee.com/chen-hao111222/images/raw/master/img/202312101654950.png)

#### 排序方法：

找到一个没有前驱的顶点，序号小的优先输出到一个线性序列中

![image-20231106201524621](https://gitee.com/chen-hao111222/images/raw/master/img/202312101654310.png)

#### 检测AOV网中是否存在环：

用拓扑排序的方法删除顶点的边，直到最后，如果发现有删除不了的边，则存在环

![image-20231106201758846](https://gitee.com/chen-hao111222/images/raw/master/img/202312101654327.png)

### 11、 AOE网（关键路径）

![image-20231106202523326](https://gitee.com/chen-hao111222/images/raw/master/img/202312101655440.png)

![image-20231106202513177](https://gitee.com/chen-hao111222/images/raw/master/img/202312101655471.png)

#### 例子：

![image-20231106202659501](https://gitee.com/chen-hao111222/images/raw/master/img/202312101655721.png)

![image-20231106203130550](https://gitee.com/chen-hao111222/images/raw/master/img/202312101655710.png)

![image-20231106203506942](https://gitee.com/chen-hao111222/images/raw/master/img/202312101655368.png)

#### 计算最早和最晚发生时间：

![image-20231106204010990](https://gitee.com/chen-hao111222/images/raw/master/img/202312101655983.png)

![image-20231106204154448](https://gitee.com/chen-hao111222/images/raw/master/img/202312101655054.png)

#### 求取步骤：

![image-20231106204916215](https://gitee.com/chen-hao111222/images/raw/master/img/202312101655510.png)

#### 讨论：

![image-20231106205457003](https://gitee.com/chen-hao111222/images/raw/master/img/202312101655022.png)





# 第七章： 查找

## 7.1 查找的基本概念：

###### 查找方法比较

![image-20231108130921180](https://gitee.com/chen-hao111222/images/raw/master/img/202312102140750.png)

###### 在哪里找：

![image-20231107160901190](https://gitee.com/chen-hao111222/images/raw/master/img/202312102140433.png)

###### 用什么查找：

![image-20231107161114912](https://gitee.com/chen-hao111222/images/raw/master/img/202312102140273.png)

###### 查找成功与否：

![image-20231107161310126](https://gitee.com/chen-hao111222/images/raw/master/img/202312102140994.png)

###### 查找的目的是什么：

查询是否存在表中，检索这个元素的各种属性，若没有可以插入数据，或者删除一个已有数据

![image-20231107161443451](https://gitee.com/chen-hao111222/images/raw/master/img/202312102140946.png)

###### 静态和动态查找表：

仅仅是查询和检索的就是静态查找表，若有插入和删除操作的则是动态查找表

![image-20231107161701169](https://gitee.com/chen-hao111222/images/raw/master/img/202312102140564.png)



##### ASL平均查找长度：

关键字的平均比较次数，把每一个关键字可能被比较的次数之和除以被查找总数

![image-20231107161924523](https://gitee.com/chen-hao111222/images/raw/master/img/202312102140643.png)

###### 查找过程中研究什么：

![image-20231107162218123](https://gitee.com/chen-hao111222/images/raw/master/img/202312102140697.png)



## 7.2.1 顺序查找：

### 类型定义：

用静态查找表，定义关键字域，定义表长，用顺序表来定义类型

![image-20231107162500471](https://gitee.com/chen-hao111222/images/raw/master/img/202312102140725.png)

```c
typedef struct {
	KeyType key;	//关键字域
    。。。。。。。		//其他域
}

typedef struct{
    //顺序表结构类型定义
    ElemType *R;	//表基址
    int length;		//表长
}SSTable;
SSTable ST;		//定义顺序表ST
```



### 查找算法过程：

从**尾部**开始找，用顺序表的长度，逐个比较对应序号的关键字是否与要查找的相同，不相同循环继续

![image-20231107163042086](https://gitee.com/chen-hao111222/images/raw/master/img/202312102140242.png)

```c
//查找算法过程，从表长最后开始和关键字对比，相同则返回序号，不同循环继续到i<1停止
int Search_Seq(SSTable ST, KeyType key){
    //i=ST.length开始查找，然后递减，直到i<1
    for(i=ST.length; i>=1; --i)
        //比较表中下标为i的值是否和关键字相同
        if (ST.R[i].key==key) return 1;
    return 0;
}
```

###### 其他形式：

把找到**关键字**作为循环停止的条件，如果i小于0后就停止循环

![image-20231107163145108](https://gitee.com/chen-hao111222/images/raw/master/img/202312102140354.png)

```c
int Search_Seq(SSTable ST, KeyType key){
    //把顺序表序号i的元素和关键字作为循环条件
    for(i=ST.length; ST.R[i].key!=key; --i)
        //如果i遍历到最前面的时候停止遍历
        if(i<=0) break;
    //如果最后i的值没有遍历完，则说明找到key的值
    if(i>0) return i;
    else return 0;
}
```

把上述两个方法**合并**，得到新的形式

![image-20231107163317710](https://gitee.com/chen-hao111222/images/raw/master/img/202312102141156.png)

![image-20231112093804639](C:\Users\23780\AppData\Roaming\Typora\typora-user-images\image-20231112093804639.png)

```c
int Search_Seq(SSTable ST,KeyType key){
   	//把对比key和i大于0一起放在循环条件中
    for(i=ST.length; ST.R[i].key!=key && i>0; --i);
    //遍历中已经排除了小于0的情况，当i>0时遍历停止说明找到key值
    if (i>0) return i;
    else return 0;
}
```



### 监视哨兵的方法：

把需要查找的关键字赋值给第0号元素，就可以减少程序，如果找不到对应的关键字就会回到序号0的位置

![image-20231107163657554](https://gitee.com/chen-hao111222/images/raw/master/img/202312102141651.png)

![image-20231107163904792](https://gitee.com/chen-hao111222/images/raw/master/img/202312102141243.png)

```c
//设置哨兵的顺序查找法
int Search_Seq(SSTable ST,KeyType key){
    ST.R[0].key=key;
    for (i=ST.length; ST.R[i].key!=ST.R[0].key; --i)
        return i;
    //因为已经把关键字放在了序号0的key中，所以最后一定能找到，所以直接返回i，无需再判断i是否>=1作为遍历结束条件
}
```

![image-20231107163933972](https://gitee.com/chen-hao111222/images/raw/master/img/202312102141410.png)



#### 时间效率分析：

![image-20231107164325835](https://gitee.com/chen-hao111222/images/raw/master/img/202312102141196.png)

#### 时间空间复杂度：

一个辅助空间就是哨兵所需要的序号0的位置，查找一个值最多需要找n-1次，所以时间复杂度为n

![image-20231107164602579](https://gitee.com/chen-hao111222/images/raw/master/img/202312102141308.png)

###### 讨论：

1. 概率越高则次数越少
2. 提高查找效率：一个序号的值每次被查找都记录一下，把查找过的值移动到表头，下次就不用查询了，

![image-20231107164921195](https://gitee.com/chen-hao111222/images/raw/master/img/202312102141667.png)



### 顺序查找优缺点：

![image-20231107165022092](https://gitee.com/chen-hao111222/images/raw/master/img/202312102141364.png)



## 7.2.2 折半查找法：

1. 每次都分成**两个部分**然后看关键字属于**哪一部分**，再重复上述操作
2. mid=(low + high) /2就是**中间点**
3. 如果key的值**大于**中间值，就移动low指针**low=mid+1**
4. 如果key的值**小于**中间值，就移动high指针**high=mid-1**
5. 当到了low<high指针重叠或者都指向mid时结束查找
6. 当**low大于high**时循环结束
7. **只能用于有序的线性表**，不能用于无序表或者链式表

![image-20231107165405357](https://gitee.com/chen-hao111222/images/raw/master/img/202312102141611.png)

### 算法思想：

![image-20231107165657632](https://gitee.com/chen-hao111222/images/raw/master/img/202312102141852.png)

###### 常规算法：

当**low大于high**时循环结束

![image-20231107165720059](https://gitee.com/chen-hao111222/images/raw/master/img/202312102141795.png)

```c
int Search_bin(SSTable ST, KeyType key){
    //设置low和high的值然后得到mid的值
    low=1;high=ST.length;	
    while (low<=high){
        mid = (low+high)/2;
        if (ST.R[mid].key == key) return mid;	//表示找到key值==mid的值，返回中间点的值就是key
        else if (key<ST.R[mid].key)		//缩小查找区间,关键字小于mid的情况
            high = mid - 1;		//移动high的指向为mid-1
        else low = mid + 1;		//否则就是大于mid的值，移动low的指向为mid+1
    }
    return 0;	//顺序表中不存在待查找元素
}
```



######  递归算法：

![image-20231107170045313](https://gitee.com/chen-hao111222/images/raw/master/img/202312102141123.png)

```c
int Search_Bin(SSTable ST, KeyType key, int low ,int high){
    if (low>high) return 0;
    mid = (low+high)/2;
    if (key==ST.elem[mid].key) return mid;
    else if (key<ST.elem[mid].key)
        .........小mid的值
        els .........大于mid的值
}
```

### 性能分析：判定树

1. 树的**层数**表示**比较的次数**，也等于从**根结点到子结点**的路径上的**结点数的个数**，
2. **比较次数**<=数的深度=log2n的地板+1
3. 每个根结点就是每次折半查找时的mid指向的序号，序号为3的值在第二次表示需要在第二次的时候比较

![image-20231107171210587](https://gitee.com/chen-hao111222/images/raw/master/img/202312102142282.png)

### 例子：

![image-20231107171642187](https://gitee.com/chen-hao111222/images/raw/master/img/202312102142332.png)

![image-20231107171758650](https://gitee.com/chen-hao111222/images/raw/master/img/202312102142179.png)

### 折半查找的优缺点：

![image-20231107171853374](https://gitee.com/chen-hao111222/images/raw/master/img/202312102142557.png)



## 7.2.3 分块查找 （索引顺序查找）

先确定在哪一块，然后再用顺序查找这个块中的数据

![image-20231108130156780](https://gitee.com/chen-hao111222/images/raw/master/img/202312102142130.png)

### 性能分析：

![image-20231108130702386](https://gitee.com/chen-hao111222/images/raw/master/img/202312102142083.png)

### 分块查找优缺点：

![image-20231108130806454](https://gitee.com/chen-hao111222/images/raw/master/img/202312102142706.png)



## 7.3 树表的查找

插入和删除比较频繁的时候就使用树的查询

![image-20231108131436341](https://gitee.com/chen-hao111222/images/raw/master/img/202312102142322.png)



## 7.3.1 二叉排序树（搜索树，查找树）

对于根结点来说**左小右大**的数，子树递归

![image-20231108131704367](https://gitee.com/chen-hao111222/images/raw/master/img/202312102142810.png)

### 例子：

二叉排序树的要求是在根的左子树的值一定是小于根结点的，右子树的值一定大于根结点

![image-20231108131916151](https://gitee.com/chen-hao111222/images/raw/master/img/202312102142061.png)



### 思考：

对非空的**二叉排序树**进行**中序遍历**可以得到一个按照关键字**递增有序**的序列

![image-20231108132330664](https://gitee.com/chen-hao111222/images/raw/master/img/202312102142034.png)



### 一、搜索树查找：

1. **关键字和根作比较**
2. **左小右大：**比根小找左子树，比根大找右子树
3. 递归到最后找到或没找到

![image-20231108132710004](https://gitee.com/chen-hao111222/images/raw/master/img/202312102142274.png)



#### 链式存储结构：

![image-20231108132855889](https://gitee.com/chen-hao111222/images/raw/master/img/202312102142266.png)

#### 算法思想：

用的是递归的操作，分别对子树进行和根结点一样的比较操作

![image-20231108133040058](https://gitee.com/chen-hao111222/images/raw/master/img/202312102143338.png)

#### 算法描述：

![image-20231108133318353](https://gitee.com/chen-hao111222/images/raw/master/img/202312102143203.png)

```c
BSTree SearchBST(BSTree T,KeyType key){
    if ((!T)|| key == T->data.key) return T;	//如果二叉树非空或者key的值和根结点的相同
    else if (key < T->data.key)		//关键字小于根的值往左子树看
        //先看完左子树然后再递归对比右子树
        return SearchBST(T->lchild, key);		//在左子树中继续查找
    else return SearchBST(T->rchild, key);		//在右子树中继续查找
}
```



#### 最多比较次数：

1. 最多比较次数==树的深度（看一共有多少层）

#### 找到比较次数

1. 找到关键字需要比较的次数==关键字结点所在的层数

![image-20231108133448372](https://gitee.com/chen-hao111222/images/raw/master/img/202312102143538.png)



#### 平均查找长度：

如果序列一开始就是有序递增的则会是最坏的情况，会形成一个只有右子树的二叉树

![image-20231108140137275](https://gitee.com/chen-hao111222/images/raw/master/img/202312102143081.png)

![image-20231108140301260](https://gitee.com/chen-hao111222/images/raw/master/img/202312102143553.png)

### 提高查找效率：

![image-20231108140414649](https://gitee.com/chen-hao111222/images/raw/master/img/202312102143153.png)



### 二、插入：

插入时看根结点和插入目标的大小比较，**比根结点小**则插入到左子树，**比根结点大**则插入到右子树

![image-20231108140650839](https://gitee.com/chen-hao111222/images/raw/master/img/202312102143067.png)

![image-20231108140916899](https://gitee.com/chen-hao111222/images/raw/master/img/202312102143569.png)



### 三、生成：

![image-20231108141049608](https://gitee.com/chen-hao111222/images/raw/master/img/202312102143627.png)

无序序列通过构造二叉排序树然后对其进行中序遍历可以得到一个有序序列

![image-20231108141140337](https://gitee.com/chen-hao111222/images/raw/master/img/202312102143043.png)

![image-20231108141402171](https://gitee.com/chen-hao111222/images/raw/master/img/202312102143310.png)

### 四、删除：

删除一个结点后仍然需要**保持二叉树的中序遍历是有序递增序列**，同时防止树的**高度增加**（会改变查找效率）

![image-20231108141457549](https://gitee.com/chen-hao111222/images/raw/master/img/202312102143697.png)



#### 删除叶子结点

![image-20231108142149383](https://gitee.com/chen-hao111222/images/raw/master/img/202312102143041.png)



#### 删除只有左或右孩子结点

直接删除再用被删除的子结点代替他就可以了

![image-20231108142253838](https://gitee.com/chen-hao111222/images/raw/master/img/202312102143273.png)

![image-20231108142342235](https://gitee.com/chen-hao111222/images/raw/master/img/202312102143195.png)

#### 删除有左右结点的结点

用一个在中序遍历中和被删除结点相邻的结点来替换

![image-20231108142539873](https://gitee.com/chen-hao111222/images/raw/master/img/202312102144314.png)

![image-20231108142824933](https://gitee.com/chen-hao111222/images/raw/master/img/202312102144882.png)

#### 删除的例子：

![image-20231108142942068](https://gitee.com/chen-hao111222/images/raw/master/img/202312102144363.png)



## 7.3.2 平衡二叉树

让二叉树的形态均衡一点，提高查找效率

**如果初始序列就是有序递增的，就会生成一个只有右分支的树**

![image-20231108143246343](https://gitee.com/chen-hao111222/images/raw/master/img/202312102144763.png)



### 定义：

平衡二叉树是具有一些特定性质的二叉排序树

1. 左右子树的|高度差|<=1
2. 左右子树都是平衡二叉树

![image-20231108143435667](https://gitee.com/chen-hao111222/images/raw/master/img/202312102144155.png)

![image-20231108143703600](https://gitee.com/chen-hao111222/images/raw/master/img/202312102144850.png)

![image-20231108144025908](https://gitee.com/chen-hao111222/images/raw/master/img/202312102144273.png)

### 平衡调整：

![image-20231108144323238](https://gitee.com/chen-hao111222/images/raw/master/img/202312102144082.png)

### 失衡的四种类型：

![image-20231108144519346](https://gitee.com/chen-hao111222/images/raw/master/img/202312102144730.png)



![image-20231108144744974](https://gitee.com/chen-hao111222/images/raw/master/img/202312102144346.png)

#### 做法:

**找到三个结点中数值处于中间的树**，然后上升到根结点，小的树放在左边，大的数放在右边

#### LL型

![image-20231108145153078](https://gitee.com/chen-hao111222/images/raw/master/img/202312102144218.png)

#### RR型

![image-20231108145415309](https://gitee.com/chen-hao111222/images/raw/master/img/202312102144353.png)



#### LR型

![image-20231108150656109](https://gitee.com/chen-hao111222/images/raw/master/img/202312102144506.png)



#### RL型

![image-20231108150947655](https://gitee.com/chen-hao111222/images/raw/master/img/202312102144994.png)



### 例子：

输入序列到平衡二叉树中时每插入一个结点都要判断平衡因子和是否失衡

![image-20231108151129557](https://gitee.com/chen-hao111222/images/raw/master/img/202312102145722.png)

![image-20231108151220538](https://gitee.com/chen-hao111222/images/raw/master/img/202312102146314.png)

![image-20231108151302509](https://gitee.com/chen-hao111222/images/raw/master/img/202312102146346.png)

![image-20231108151450626](https://gitee.com/chen-hao111222/images/raw/master/img/202312102146202.png)

![image-20231108151529288](https://gitee.com/chen-hao111222/images/raw/master/img/202312102146453.png)



## 7.4.1 散列表的查找

![image-20231108151658585](https://gitee.com/chen-hao111222/images/raw/master/img/202312102146611.png)

### 如何查找：

可以直接对应查找到散列表就可以找到对应的数据

![image-20231108151906927](https://gitee.com/chen-hao111222/images/raw/master/img/202312102146897.png)

#### 查找过程：

![image-20231108155128156](https://gitee.com/chen-hao111222/images/raw/master/img/202312102146353.png)

### 散列表的术语：

#### 杂凑法：

![image-20231108152036095](https://gitee.com/chen-hao111222/images/raw/master/img/202312102146097.png)

![image-20231108152150977](https://gitee.com/chen-hao111222/images/raw/master/img/202312102146586.png)

#### 冲突：

![image-20231108152317556](https://gitee.com/chen-hao111222/images/raw/master/img/202312102146210.png)

![image-20231108152431043](https://gitee.com/chen-hao111222/images/raw/master/img/202312102146075.png)



### 散列函数的构造方法：

减少空间浪费，均匀分布减少冲突

![image-20231108152531865](https://gitee.com/chen-hao111222/images/raw/master/img/202312102146394.png)

![image-20231108152702881](https://gitee.com/chen-hao111222/images/raw/master/img/202312102147819.png)

![image-20231108152821313](https://gitee.com/chen-hao111222/images/raw/master/img/202312102147841.png)



#### 直接定址法：

空间效率低，不会产生冲突，一线性函数值作为散列地址

![image-20231108152940803](https://gitee.com/chen-hao111222/images/raw/master/img/202312102147010.png)

#### 除留余数法：

找一个**小于元素个数的素数**，然后拿元素来除以素数的**余数来作为序号**进行排序

![image-20231108153205660](https://gitee.com/chen-hao111222/images/raw/master/img/202312102147081.png)



### 解决冲突的方法

#### 一：开放定址法

![image-20231108153421379](https://gitee.com/chen-hao111222/images/raw/master/img/202312102147690.png)



##### 线性探测法：

如果一个元素取余之后的地址**已经被占了，则存储在下一个元素中**，逐个存储

![image-20231108153754813](https://gitee.com/chen-hao111222/images/raw/master/img/202312102147003.png)

##### 二次探测法：

取余之后地址被占**则加或减二次方的值**找到一个没有被占的地址存储

![image-20231108154240654](https://gitee.com/chen-hao111222/images/raw/master/img/202312102147794.png)

##### 伪随机探测法：

![image-20231108154425718](https://gitee.com/chen-hao111222/images/raw/master/img/202312102147570.png)



#### 二：链地址法：

把取余之后余数相等（冲突）的元素放在一个链表里面存储

**比如14，1，27取余13之后都是1则把他放在1后面的链式表中**

![image-20231108154646561](https://gitee.com/chen-hao111222/images/raw/master/img/202312102147929.png)

##### 实现步骤：

![image-20231108154838661](https://gitee.com/chen-hao111222/images/raw/master/img/202312102147464.png)

##### 优点：

![image-20231108154925253](https://gitee.com/chen-hao111222/images/raw/master/img/202312102147968.png)



### 例子：

![image-20231108155410520](https://gitee.com/chen-hao111222/images/raw/master/img/202312102147914.png)

![image-20231108155501304](https://gitee.com/chen-hao111222/images/raw/master/img/202312102147147.png)

### 效率分析：

![image-20231108155634438](https://gitee.com/chen-hao111222/images/raw/master/img/202312102148761.png)

![image-20231108155704435](https://gitee.com/chen-hao111222/images/raw/master/img/202312102148257.png)

### 结论：

![image-20231108155806589](https://gitee.com/chen-hao111222/images/raw/master/img/202312102148683.png)







# 第八章： 排序

## 什么是排序：

![image-20231108160016828](https://gitee.com/chen-hao111222/images/raw/master/img/202311161935064.png)

## 排序方法分类：

![image-20231108160158072](https://gitee.com/chen-hao111222/images/raw/master/img/202311161935416.png)

![image-20231108160242209](https://gitee.com/chen-hao111222/images/raw/master/img/202311161935671.png)

![image-20231108160314693](https://gitee.com/chen-hao111222/images/raw/master/img/202311161935941.png)

![image-20231108160355637](https://gitee.com/chen-hao111222/images/raw/master/img/202311161935341.png)

![image-20231108160434459](https://gitee.com/chen-hao111222/images/raw/master/img/202311161935294.png)

![image-20231108160514405](https://gitee.com/chen-hao111222/images/raw/master/img/202311161936630.png)

![image-20231108160607342](https://gitee.com/chen-hao111222/images/raw/master/img/202311161936917.png)

**排序稳定只对结构类型数据排序有意义**

![image-20231108160708614](https://gitee.com/chen-hao111222/images/raw/master/img/202312102149306.png)

![image-20231108160832077](https://gitee.com/chen-hao111222/images/raw/master/img/202312102149628.png)

![image-20231108160923320](https://gitee.com/chen-hao111222/images/raw/master/img/202312102149939.png)

## 存储结构：

1. 以顺序表存储
2. 假设关键字为int型
3. 多关键字，有多个数据项
4. 0序列用来作为哨兵或者缓冲区，不存储关键字元素值

![image-20231108161243792](https://gitee.com/chen-hao111222/images/raw/master/img/202312102149219.png)

## 8.2 插入排序：

### 有序插入：

![image-20231108162937182](https://gitee.com/chen-hao111222/images/raw/master/img/202312102149569.png)

#### 插入（前中后）方法：

![image-20231108163151494](https://gitee.com/chen-hao111222/images/raw/master/img/202312102149990.png)

![image-20231108163310800](https://gitee.com/chen-hao111222/images/raw/master/img/202312102149498.png)



#### 插入排序种类：

![image-20231108163425477](https://gitee.com/chen-hao111222/images/raw/master/img/202312102149001.png)





## 一、直接插入排序法：

到第i个元素了，就从i-1（就是前面一个元素）个元素开始比较前面的值的大小

当找到一个和第i个元素相等的值就停止或者当j<0时停止

当找到相等的第j序号的元素之后，把其赋值给下一个地址，然后把空出的第j地址填入i元素

![image-20231108164051611](https://gitee.com/chen-hao111222/images/raw/master/img/202312102149378.png)

```c
x=a[i];
//如果比较之后比关键字大则往后移动一位
for(j=i-1; j>=0 && x<a[j]; j--)
    a[j+1] = a[j];
//找到较小的值后就跳出循环，然后赋值
//当找到比关键字小的值后就把第i位置的元素插入到其后面的位置
a[j+1]=x;
```

#### 使用哨兵的排序：

1. 由于每次都要比较两次，所以加入带哨兵的方法排序，把关键字放在第0号元素中作为哨兵
2. 如果关键字比最后一个元素都要大，则不需要插入排序，就不需要赋值给哨兵

![image-20231108165108383](https://gitee.com/chen-hao111222/images/raw/master/img/202312102149369.png)



#### 加上哨兵之后的算法实现：

![image-20231108165650138](https://gitee.com/chen-hao111222/images/raw/master/img/202312102149170.png)

```c
void InsertSort(SqList &L){
    int i,j;
    for(i=2; i<=L.length; ++i){
		if (L.r[i].key<L.r[i-1].key){//先比较前面的两个值的大小i=2,和序号为1的值比较
            L.r[0]=L.r[i];//上述的完成后，就可以把序号为i=2的元素放在哨兵里面和后面的值比较了
            for (j=i-1; L.r[0].key<L.r[j].key; --j){//一开始，i和j的值就是无序和有序连接的两个值
                //j的值会一直移动到一个大于哨兵的值的地方停止跳出循环
                L.r[j+1]=L.r[j];//
            }//for
            L.r[j+1]=L.r[0];//接着上面跳出循环的j，j+1后就相当于被移走的那个元素的序号了
        }//if
    }//for
}
```

![在这里插入图片描述](https://gitee.com/chen-hao111222/images/raw/master/img/202312102149404.gif)

### 性能分析：

#### 最好情况：

![image-20231108165918121](https://gitee.com/chen-hao111222/images/raw/master/img/202312102149617.png)

#### 最坏情况：

![image-20231108170118734](https://gitee.com/chen-hao111222/images/raw/master/img/202312102149977.png)

#### 平均情况：

![image-20231108170144502](https://gitee.com/chen-hao111222/images/raw/master/img/202312102150058.png)



### 时间复杂度的结论：

![image-20231108170343448](https://gitee.com/chen-hao111222/images/raw/master/img/202312102150546.png)





## 二、折半插入排序法：

插入的时候也是和顺序插入一样，但是在和前面比较的时候是用的折半查找法

![image-20231108170711401](https://gitee.com/chen-hao111222/images/raw/master/img/202312102150881.png)

### 算法思想：

先把关键字赋值给哨兵，然后哨兵和mid中间元素比较大小，如果哨兵小于中间元素，则把high调整为mid-1的地址，反之把low调整为mid+1的地址，当low大于high时循环结束，则high+1就是要插入的位置，**然后再把从i-1的元素开始往后移动一个位置，直到j<high+1位置时停止移动，把哨兵元素插入到high+1位置**

### 算法实现：

![image-20231108170928062](https://gitee.com/chen-hao111222/images/raw/master/img/202312102150097.png)

```c
void BInserSort(SqList &L){
    for(i=2; i<=L.length; ++i){
        L.r[0] = L.r[i];	//当前插入元素存到哨兵位置
        
        low = 1;
        high = i-1;		//采用二分法查找，high的位置和二分法的相同，但是表示方法不一样
        
        while (low<=high){	//当low>high时结束循环
            mid = (low+high)/2;
            if (L.r[0].key < L.r[mid].key) 
                high=mid-1;		//中间点的值较大时，移动high到mid-1
            else low = mid + 1;//中间点的值较小时，移动high到mid+1
        }//while
        
        //把后面的元素依次后移，第一个要移动的是i-1这个位置的值，一直到high+1的位置
        for (j=i-1; j>=high+1; --j)
            L.r[j+1]=L.r[j];	//移动元素
        L.r[high+1]=L.r[0];		//插入到正确位置
    }//for
}
```

### 算法分析：

![image-20231108171931151](https://gitee.com/chen-hao111222/images/raw/master/img/202312102150785.png)

![image-20231108172023742](https://gitee.com/chen-hao111222/images/raw/master/img/202312102150609.png)



## 希尔排序：

![image-20231108214527461](https://gitee.com/chen-hao111222/images/raw/master/img/202312102150513.png)

![image-20231108214711639](https://gitee.com/chen-hao111222/images/raw/master/img/202312102150586.png)

### 排序过程：

先把一段数据分成五个五个间隔的排序，然后每段中的每个来比较，然后再把小的数值放到前面，五个分段的弄完之后，就再三个分段来搞，然后再一个来搞，最后到排序完成

![image-20231108215043742](https://gitee.com/chen-hao111222/images/raw/master/img/202312102150016.png)

![image-20231108215537031](https://gitee.com/chen-hao111222/images/raw/master/img/202312102150642.png)

### 特点：

![image-20231108215636494](https://gitee.com/chen-hao111222/images/raw/master/img/202312102150843.png)



### 算法实现：

把间隔值存储在一个序列中，然后再逐个取出使用，直到用完序列中的值

![image-20231108215749109](https://gitee.com/chen-hao111222/images/raw/master/img/202312102150323.png)

和插入排序算法差不多，区别在于插入排序中每次跳一个，**而希尔排序中每次跳一个间隔**

![image-20231108220848762](https://gitee.com/chen-hao111222/images/raw/master/img/202312102150154.png)

```c
void ShellSort(Sqlist &L, int dlta[], int t){
    for (k=0; k<t; ++k)
        ShellInsert(L, dlta[k]);	//设置好增量k的值
}

void ShellInsert(SqList &L, int dk){
    //对顺序表L进行一趟增量为dk的Shell排序，dk为步长
    for (i=dk+1; i<=L.length; ++i)		//跨一个间隔进行对比
        //i-dk相当于i-1，但是这里是减去一个间隔
        if (r[i].key < r[i-dk].key){	//第一个i和上一个间隔的i比较
            r[0]=r[i];	//把较小的那个赋值给序号0
            for (j=i-dk; j>0 && (r[0].key<r[j].key); j=j-dk)	//j的变化就是减去一个间隔，
                r[j+dk]=r[j];		//移动元素也是要移动一个间隔
            r[j+dk]=r[0];
        }
}
```



### 算法分析：

![image-20231108221038137](https://gitee.com/chen-hao111222/images/raw/master/img/202312102150497.png)

![image-20231108221240211](https://gitee.com/chen-hao111222/images/raw/master/img/202312102150777.png)

### 不稳定的算法：

![image-20231108221147988](https://gitee.com/chen-hao111222/images/raw/master/img/202312102151578.png)



## 8.3 交换排序

![image-20231108221710636](https://gitee.com/chen-hao111222/images/raw/master/img/202312102151010.png)





## 8.3.1 冒泡排序

每个元素都从头开始一个元素进行比较，然后看大小移动

![image-20231108222719170](https://gitee.com/chen-hao111222/images/raw/master/img/202312102151343.png)

### 升序：

![image-20231108224010266](https://gitee.com/chen-hao111222/images/raw/master/img/202312102151635.png)

![image-20231108224113046](https://gitee.com/chen-hao111222/images/raw/master/img/202312102151874.png)

![image-20231109182021848](https://gitee.com/chen-hao111222/images/raw/master/img/202312102151952.png)

每一趟增加一个有序元素，就减少一次比较的次数

#### 比较趟数：

有n个元素就需要比较n-1趟

**第M趟需要比较次数=元素个数n-趟数M**

#### 算法实现：

![image-20231109182332926](https://gitee.com/chen-hao111222/images/raw/master/img/202312102151005.png)

```c
void bubble_sort(SqList &L){//冒泡排序法
    int m,i,j;
    RedType x;		//创建一个临时存储空间来存放交换时的元素值
    for (m=1; m<=n-1; m++){		//一共要走的趟数=元素个数-1
        for (j=1; j<n-m; j++)	//每一趟需要比较的次数=元素个数-趟数
            if(L.r[j].key>L.r[j+1].key) {		//如果前面的数值大于后面的则交换
                x=L.r[j]; L.r[j]=L.r[j+1]; L.r[j+1]=x;	//交换
                //交换方法：先把前面的值赋值给x然后把后面的值赋值给前面已经空的地址，然后再把x中存放的前面的值赋值到后面的地址中
            }
    }
}
```

#### 优点：

![image-20231109183327209](https://gitee.com/chen-hao111222/images/raw/master/img/202312102151451.png)

#### 改进：

如果发现到后面的已经是有序的了，就不需要再进行排序了

![image-20231109183429834](https://gitee.com/chen-hao111222/images/raw/master/img/202312102151907.png)

#### 改进算法实现：

设置一个flag=1作为是否需要发生交换的前提，循环开始时先把flag置为零，然后当发生逆序时再把flag置为一再进行交换，如果flag一直为0则重新下一个循环的开始

![image-20231109183527972](https://gitee.com/chen-hao111222/images/raw/master/img/202312102151505.png)

```c
void bubble_sort(SqList &L){
	int m,j,i,flag=1;	//设置一个flag值
	RedType x;
	for (m=1;m<n-1 && flag=1;m++){	//循环的条件加多了一个flag，如
	flag = 0;		//先把flag值置零
        for (j=1;j<n-m;j++)		//每趟比较次数
            if (L.r[j].key>L.r[j+1].key)
            {
                flag=1;		//如果需要逆转则把flag置一
                x=L.r[j];
                L.r[j]=L.r[j+1];
                L.r[j+1]=x;
            }
	}
}
```



#### 算法分析：

![image-20231109183858167](https://gitee.com/chen-hao111222/images/raw/master/img/202312102151309.png)

![image-20231109183922902](https://gitee.com/chen-hao111222/images/raw/master/img/202312102151529.png)



## 8.3.2 快速排序

任取一个元素为中心，比他大放后面，比他小放前面，分成两个子表，用递归的方式来排序子表，递归的结束条件是只剩下一个元素

![image-20231109184233220](https://gitee.com/chen-hao111222/images/raw/master/img/202312102151573.png)



![image-20231109184509458](https://gitee.com/chen-hao111222/images/raw/master/img/202312102151673.png)

![image-20231109184754895](https://gitee.com/chen-hao111222/images/raw/master/img/202312102151929.png)



### 改进思路：

由于需要空间太大，则改进为另外一种方法

把序号1元素赋值给序号0，然后定义序号2元素为low，最后一个元素为high，由于序号1空了，则需要从后面找一个比原序号2小的值填到空的序号1的位置，如果后面的值移动到了前面出现了空位，则需要从前面开始找

![image-20231109190229202](https://gitee.com/chen-hao111222/images/raw/master/img/202312102152433.png)

![image-20231109190407575](https://gitee.com/chen-hao111222/images/raw/master/img/202312102152467.png)

### 算法实现：

关键是找到中心点的位置来分成两部分，low到中心点-1，high到中心点+1

![image-20231109190541223](https://gitee.com/chen-hao111222/images/raw/master/img/202312102152931.png)

### 找中心点的算法实现：

![image-20231109191549534](https://gitee.com/chen-hao111222/images/raw/master/img/202312102152224.png)

```c
//找中心点算法实现
int Partition (SqList &L, int low, int high){
    L.r[0]=L.r[low];	//把low地址的值赋值给序号0
    pivotkey=L.r[low].key;		//最开始中心点的值为low的值
    while (low<high){		//当二者重叠结束循环
        //先从high这边开始查找有没有比中心点小的值把他移动到low这里来
        while (low<high && L.r[high].key >= pivotkey) --high;	
        //没找到比中心点小的值,high自减，继续循环
        
        //当high这边空出时，就要从low这边开始查找比中心点大的时移动到high
        while (low<high && L.r[low].key <= pivotkey) ++low;
        //没找到比中心点大的值,low自减，继续循环
    }
    //当上面两个循环都结束后，把序号0的元素的值赋值给low输出作为中心点
    L.r[low] = L.r[0];
    return low;
}

//直接排序算法实现
void main(){
    QSort(L,1,L.length);	//递归算法实现排序
}

//使用递归算法对顺序表排序
void QSort(Sqlist &L,int low, int high){	//排序
    if(low<high){	//分段的顺序表中元素大于一，low和high不重叠
        pivotloc = Partition(L,low,high);
        	//将L.r[low...high]一分为二，pivotloc为中心点元素排序的位置
        QSort(L,low,pivotloc-1);	//对元素较小的子表递归排序
        QSort(L,pivotoc+1,high);	//对元素较大的子表递归排序
    }
}
```



### 算法分析：

![image-20231109191711952](https://gitee.com/chen-hao111222/images/raw/master/img/202312102152874.png)

需要用到栈的就不是原地排序

![image-20231109191811177](https://gitee.com/chen-hao111222/images/raw/master/img/202312102152857.png)

![image-20231109191841268](https://gitee.com/chen-hao111222/images/raw/master/img/202312102152730.png)

### 快速排序不适合有序序列：

![image-20231109191947533](https://gitee.com/chen-hao111222/images/raw/master/img/202312102152995.png)

### 越乱就越好，排序速度越快

![image-20231109192118735](https://gitee.com/chen-hao111222/images/raw/master/img/202312102152173.png)



## 8.4.1 简单选择排序

![image-20231109221824179](https://gitee.com/chen-hao111222/images/raw/master/img/202312102152946.png)

### 排序过程：

从第一个开始逐个对比找出比他小的值，**相互交换**，有n个元素则需要排序n-1趟排序

![image-20231109222056231](https://gitee.com/chen-hao111222/images/raw/master/img/202312102152498.png)

![image-20231109222009443](https://gitee.com/chen-hao111222/images/raw/master/img/202312102152633.png)



### 算法实现：

![image-20231109223153391](https://gitee.com/chen-hao111222/images/raw/master/img/202312102152555.png)

```c
void SelectSort(SqList &K){
    for (i=1; i<L.length; ++i){		//从第一个元素开始和后面的元素进行比较
        k=i;	//先把第一个元素赋值给k
        for (j=i+1; j<=L.length; j++)	//从第i的后一个元素开始比较
            if (L.r[j].key < L.r[K].key) k=j;	
        //记录最小值位置，就是拿一开始赋值的第i个元素和目前的元素比较，要是比关键字i小就要交换
        if (k!=i) L.r[i]交换L.r[k];		//交换
    }
}
```

### 算法分析：

![image-20231109224234410](https://gitee.com/chen-hao111222/images/raw/master/img/202312102153537.png)



## 堆排序：

可以看出二叉树，父结点要大于或者小于自己的两个孩子的值

![image-20231109224514513](https://gitee.com/chen-hao111222/images/raw/master/img/202312102153129.png)

### 判断是否为堆：

![image-20231109224700401](https://gitee.com/chen-hao111222/images/raw/master/img/202312102153201.png)

![image-20231109224756896](https://gitee.com/chen-hao111222/images/raw/master/img/202312102153089.png)



### 定义：

每次输出堆顶元素来组成一个有序序列

![image-20231109224936665](https://gitee.com/chen-hao111222/images/raw/master/img/202312102153506.png)

### 问题：

![image-20231109225104055](https://gitee.com/chen-hao111222/images/raw/master/img/202312102153296.png)

### 排序过程：

![image-20231109225749607](https://gitee.com/chen-hao111222/images/raw/master/img/202312102153665.png)

在小根堆里面，把一个小根堆的堆顶元素输出到顺序表中，然后把序号最后的结点放在根结点上，然后比较其和左右子树的值的大小，如果大于子树的值则调下去，然后重复，直到形成有序序列

![image-20231109225935423](https://gitee.com/chen-hao111222/images/raw/master/img/202312102153890.png)

### 算法描述：

![image-20231109230206032](https://gitee.com/chen-hao111222/images/raw/master/img/202312102153550.png)

### 结论：

![image-20231109230341810](https://gitee.com/chen-hao111222/images/raw/master/img/202312102153731.png)

### 堆的建立：

![image-20231109230816735](https://gitee.com/chen-hao111222/images/raw/master/img/202312102153361.png)

#### 过程：

![image-20231109231028295](https://gitee.com/chen-hao111222/images/raw/master/img/202312102153308.png)



从最后一个**叶子结点n**的**父结点n/2**开始，n/2结点和其子树比较大小，然后交换，在到第n/2-1个结点和其子树比较，一直到整棵树的根结点处，然后再从上往下比较交换

#### 从下往上比较

![image-20231109231325124](https://gitee.com/chen-hao111222/images/raw/master/img/202312102153914.png)

#### 从上往下比较

![image-20231109231646950](https://gitee.com/chen-hao111222/images/raw/master/img/202312102153819.png)

![image-20231109231752486](https://gitee.com/chen-hao111222/images/raw/master/img/202312102153681.png)

![image-20231109231837272](https://gitee.com/chen-hao111222/images/raw/master/img/202312102153194.png)



### 算法实现：

![image-20231109232002050](https://gitee.com/chen-hao111222/images/raw/master/img/202312102154738.png)



### 算法分析：

![image-20231109232134879](https://gitee.com/chen-hao111222/images/raw/master/img/202312102154380.png)



![image-20231109232202231](https://gitee.com/chen-hao111222/images/raw/master/img/202312102154338.png)

![image-20231109232241390](https://gitee.com/chen-hao111222/images/raw/master/img/202312102154122.png)



## 8.5 归并排序

### 基本思想：

![image-20231110102507764](https://gitee.com/chen-hao111222/images/raw/master/img/202312102154890.png)

### 过程：

两个两个合并成一个集合，然后逐个合并成一个大的序列

![image-20231110102816800](https://gitee.com/chen-hao111222/images/raw/master/img/202312102154437.png)

![image-20231110102627235](https://gitee.com/chen-hao111222/images/raw/master/img/202312102154475.png)



### 合并两个有序序列

因为两个都是有序的顺序表，先对比每个表中第一个元素，较小的拿出来放在新表中，然后移动指针对比下一个元素值的大小，逐个取出到新表中

![image-20231110103039533](https://gitee.com/chen-hao111222/images/raw/master/img/202312102154939.png)

### 算法思想：

1. 归并排序中的两个有序的顺序表是连续的，第一个表：low—m，第二个表：m+1—high
2. i'和j分别指向两个顺序表的第一个元素，开始比较大小，小的放到新表中

![image-20231110103605349](https://gitee.com/chen-hao111222/images/raw/master/img/202312102154546.png)



### 算法分析：

![image-20231110103817507](https://gitee.com/chen-hao111222/images/raw/master/img/202312102154116.png)

## 8.6 基数排序

![image-20231110104009180](https://gitee.com/chen-hao111222/images/raw/master/img/202312102154267.png)



### 排序过程：

第一趟：看数值的个位数作为排序的序号，和下标一一对应，然后在按照桶输出值

![image-20231110104121774](https://gitee.com/chen-hao111222/images/raw/master/img/202312102154573.png)

第二趟：同上一样，不同是按照数值的十位数来排序

![image-20231110104358757](https://gitee.com/chen-hao111222/images/raw/master/img/202312102155112.png)

第三趟：按照百位来排序，可以完成排序

![image-20231110104457103](https://gitee.com/chen-hao111222/images/raw/master/img/202312102155131.png)



### 算法分析：

1. 需要排序多少次要看关键字有多少，个十百千万
2. 只是对关键字取值范围一定的比较好排序，如果关键字分布和数值较大，则效率不好

![image-20231110104623224](https://gitee.com/chen-hao111222/images/raw/master/img/202312102155716.png)



# 各种排序的比较：

![image-20231110104955854](https://gitee.com/chen-hao111222/images/raw/master/img/202312102155932.png)



## 时间性能：

![image-20231110105152518](https://gitee.com/chen-hao111222/images/raw/master/img/202312102155248.png)

![image-20231110105315858](https://gitee.com/chen-hao111222/images/raw/master/img/202312102155570.png)

## 空间性能：

![image-20231110105432535](https://gitee.com/chen-hao111222/images/raw/master/img/202312102155049.png)

## 稳定性：

![image-20231110105538744](https://gitee.com/chen-hao111222/images/raw/master/img/202312102155768.png)

## 排序方法的时间复杂度的下限

![image-20231110105658830](https://gitee.com/chen-hao111222/images/raw/master/img/202312102155242.png)


